<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Bài 4: Cách thiết kế Instagram | LifeSucks</title>
<meta name=keywords content="system design interviews,Design photo-sharing service,Design Instagram">
<meta name=description content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ chia sẻ photo giống như Instagram, nơi mà người dùng users có thể tải lên photos và chia sẻ chúng với những người khác">
<meta name=author content="telion">
<link rel=canonical href=https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lifesucks.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://lifesucks.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://lifesucks.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://lifesucks.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://lifesucks.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet type=text/css href=https://lifesucks.dev/css/custom.css>
<meta property="og:title" content="Bài 4: Cách thiết kế  Instagram">
<meta property="og:description" content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ chia sẻ photo giống như Instagram, nơi mà người dùng users có thể tải lên photos và chia sẻ chúng với những người khác">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/"><meta property="og:image" content="https://lifesucks.dev/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/"><meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://lifesucks.dev/papermod-cover.png">
<meta name=twitter:title content="Bài 4: Cách thiết kế  Instagram">
<meta name=twitter:description content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ chia sẻ photo giống như Instagram, nơi mà người dùng users có thể tải lên photos và chia sẻ chúng với những người khác">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifesucks.dev/posts/"},{"@type":"ListItem","position":2,"name":"Bài 4: Cách thiết kế  Instagram","item":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bài 4: Cách thiết kế  Instagram","name":"Bài 4: Cách thiết kế  Instagram","description":"Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ chia sẻ photo giống như Instagram, nơi mà người dùng users có thể tải lên photos và chia sẻ chúng với những người khác","keywords":["system design interviews","Design photo-sharing service","Design Instagram"],"articleBody":"1. Instagram là gì? Instagram là 1 dịch vụ mạng xã hội cho phép người dùng users upload và chia sẻ các hình ảnh photos và videos của họ với những người khác. Người dùng Instagram có thể lựa chọn chia sẻ thông thông qua cả 2 hình thức công khai publicly và riêng tư privately. Bất cứ thứ gì được chia sẻ công khai có thể được nhìn thấy bởi người dùng khác, mặt khác những nội dung chia sẻ riêng tư sẽ chỉ được truy cập bởi 1 nhóm người dùng cụ thể. Instagram cho phép người dùng nó chia sẻ thông qua nhiều nền tảng mạng xã hội khác, giống như Facebook, Twitter, Flickr, và Tumblr.\nChúng ta sẽ lên kế hoạch thiết kế 1 phiên bản đơn giản hơn của Instagram vì mục đích thiết kế, nơi mà người dùng user có thể chia sẻ photos và follow những người khác. “News Feed” cho từng user sẽ chỉ bao gồm các top photos của tất cả gười dùng khác mà user đang follows.\n2. Yêu cầu Requirements và mục tiêu Goals của hệ thống Chúng ta sẽ tập trung vào các tập yêu cầu như sau khi thực hiện thiết kế Instagram.\nCác yêu cầu về mặt tính năng:\n Users có thể upload/download/view photos. Users có thể thực hiện các tìm kiếm trên các tiêu đề photo/video. Users có thể theo dõi follow người khác. Hệ thống sẽ tạo và hiện thị News Feed của user - Chứa các top photos của tất cả các người dùng mà họ theo dõi.  Yêu cầu không liên quan tới tính năng:\n Hệ thống cần có tính sẵn sàng cao. Độ trễ có thể chấp nhận được của hệ thống là 200ms cho việc tạo ra News Feed. Hệ thống chấp nhận tính nhất quán có thể ảnh hưởng nếu người dùng không nhìn thấy 1 photo trong 1 khoảng thời gian. Hệ thống có độ tin cậy cao, bất cứ photo hay video nào đã được upload thì sẽ không bao giờ bị mất.  Không nằm trong scope: Việc theo tags vào photos, tìm kiếm photos dựa trên tag, bình luận vào photos, tagging người dùng user vào photos, etc.\n3. 1 vài chú ý cần xem xét đến khi thực hiện thiết kế Hệ thống sẽ nặng tải về read, do vậy ta sẽ tập trung vào xây dựng 1 hệ thống sao cho việc lấy ra các photos 1 cách nhanh nhất.\n Thực tế, users có thể upload bao nhiêu photos tùy thích, do vậy việc quản lý lưu trữ storage 1 cách hiệu quả sẽ là 1 nhân tố đóng vai trò quan trọng trong thiết kế hệ thống. Độ trễ thấp như kỳ vọng khi thực hiện viewing photos. Data cũng cần 100% tin cậy. Nếu 1 user upload 1 photo thì hệ thống sẽ đảm bảo nó sẽ không bao giờ bị mất.  4. Định lượng sức chứa Capacity và các ràng buộc Constraints  Ta giả sử chúng ra có tổng số 500M users, với 1M user hoạt động hàng ngày. 2M photos mới được tạo ra mỗi ngày, 23 new photos mỗi giây. Trung bình kích thước 1 photo = 200KB. Tổng số lưu trữ bắt buộc cho tất cả photos trong 1 ngày là: 2M * 200KB = 400 GB Tổng số lưu trữ bắt buộc cho tất cả photos trong 10 năm là: 400GB *365 (days a year)* 10 (years) ~= 1425TB  5. High Level System Design Ở mức high-level, chúng ta cần support 2 ngữ cảnh, 1 là thực hiện upload photos, 2 là khi thực hiện view/search photos. Do đó dịch vụ chúng ta thiết kế sẽ cần các object storage servers để lưu tữ photos và database servers để lưu trữ các thông tin metadata của photos.\n6. Database Schema  Việc định nghiã DB schema ở những giai đoạn đầu tiên của cuộc phỏng vấn sẽ giúp mọi người hiểu về luồng data flow giữa các thành phần components khác nhau trong hệ thống và giúp định hướng cách phân vùng dữ liệu data partitioning sau này.\n Chúng ta cần lưu trữ dữ liệu về users, các photos được upload lên bởi họ, những người họ đang theo dõi follow. bảng Photo sẽ chứa tất cả các dữ liệu liên quan tới ảnh photo; chúng ta cần đánh index trên cặp (PhotoID, CreationDate) do ta cần lấy ra những photo được upload lên gần đây trước tiên.\n1 cách tiếp cận hết sức hiển nhiên cho việc lưu trữ giống như database schema ở trên là sử dụng 1 RDBMS như MySQL do ta có sử dụng đến joins. Nhưng databases quan hệ cũng đi cùng những thách thức của chúng, đặc biệt là khi ta cần mở rộng scale chúng.\nChúng ta có thể lưu trữ photos ở những hệ thống lưu trữ phân tán file distributed file storage giống như HDFS hay S3.\nChúng ta có thể lưu trữ dữ liệu ở schema trên dưới dạng lưu trữ phân tán distributed key-value để tận dựng được các ưu điểm của NoSQL. Tất cả các thông tin metadata liên quan tới photos lưu trữ trong 1 table mà có key là ‘PhotoID’ và value sẽ la 1 object chứa các thông tin PhotoLocation, UserLocation, CreationTimestamp, etc.\nNếu chúng ta chọn giải pháp sử dụng 1 NoSQL database, chúng ta cần thêm 1 table nữa để lưu trữ quan hệ relationships giữa users và photos để biết được ai đang sở hữu photo nào. Chúng ta sẽ gọi bảng này là ‘UserPhoto’. Chúng ta cũng cần lưu trữ danh sách các người mà 1 user đang theo dõi follow. Chúng ta gọi bảng này là ‘UserFollow’. Với những bảng table dạng này, ta có thể sử dụng 1 kiểu wide-column datastore giống như Cassandra. Ví với bảng UserPhoto, với key là UserID và value là danh sách các PhotoIDs mà user sở hữu, được lưu trữ ở các cột columns khác nhau. Chúng ta sẽ có schema tương tự cho bảng UserFollow.\nCassandra hay các kiểu key-value stores, thông thường luôn duy trì 1 số lượng các bản sao replicas để đảm bảo tính sẵn sàng của hệ thống. Và cũng ở trong những data stores dạng này, việc xóa deletes sẽ không được áp dụng ngay lập tức; dữ liệu data sẽ vẫn còn được lưu trữ trong vài ngày (hỗ trợ trường hợp muốn undeleting) trước khi bị xóa vĩnh viễn khỏi hệ thống.\n7. Ước lượng Data Size Chúng ta sẽ ước lượng cách mà dữ liệu data sẽ gia tăng ở từng bảng table và tổng số lưu trữ storage mà ta cần lưu trữ trong 10 năm.\nUser: Giả sử rằng mỗi kiểu dữ liệu ‘int’ và ‘dataTime’ cần 4 bytes để lưu trữ, mỗi dòng row trong bảng User sẽ cần 68 bytes:\nUserID (4 bytes) + Name (20 bytes) + Email (32 bytes) + DateOfBirth (4 bytes) + CreationDate (4 bytes) + LastLogin (4 bytes) = 68 bytes Nếu chúng ta có 500M users, thì ta sẽ cần 32GB để lưu trữ:\n500 million * 68 ~= 32GB Photo: Mỗi row trong bảng Photo sẽ cần 284 bytes:\nPhotoID (4 bytes) + UserID (4 bytes) + PhotoPath (256 bytes) + PhotoLatitude (4 bytes) + PhotoLongitude(4 bytes) + UserLatitude (4 bytes) + UserLongitude (4 bytes) + CreationDate (4 bytes) = 284 bytes Nếu có 2M photos mới được upload mỗi ngày, chúng ta sẽ cần 0.5GB lưu trữ cho mỗi ngày:\n2M * 284 bytes ~= 0.5GB per day Với 10 năm, ta sẽ cần 1.88TB lưu trữ.\nUserFollow: Mỗi row trong UserFollow sẽ cần 8 bytes. Nếu ta có 500M users và trung bình mỗi user sẽ thực hiện theo dõi follow 500 người khác. Chúng ta sẽ cần 1.82TB lưu trữ cho UserFollow:\n500 million users * 500 followers * 8 bytes ~= 1.82TB Tổng dung lượng cần để lưu trữ tất cả các tables trong vòng 10 năm sẽ là 3.7TB:\n32GB + 1.88TB + 1.82TB ~= 3.7TB 8. Component Design Việc photo được upload (hay write) có thể trở nên chậm nếu chúng được ghi trực tiếp vào ổ disk, trong khi việc đọc reads sẽ nhanh hơn, đặc biệt nếu chúng được đọc từ cache.\nNhững người dùng thực hiện upload có thể sử dụng hết các connections hiện có của hệ thống, do việc thực hiện uploading được xét là 1 slow process. Điều này có nghĩa là reads có thể bị ảnh hưởng nếu hệ thống bị quá tải với các write request. Chúng ta cũng cần lưu ý rằng 1 web server luôn có 1 ngưỡng giới hạn connection limit. Ta giả sử rằng web server có 1 ngưỡng giới hạn là 500 connections tại 1 thời điểm, thì nó không thể có hơn 500 uploads hay reads cùng lúc. Để khắc phục nghẽn cổ chai này, ta có thể phân chia reads và writes vào các serivces độc lập. Chúng ta sẽ có các servers dành riêng cho việc reads và các server khác dành riêng cho việc writes để đảm bảo việc upload không ảnh hưởng tới cả hệ thống.\nViệc tách biệt read và write requests cũng cho phép ta mở rộng và tối ưu từng loại xử lý 1 cách độc lập:\n9. Độ tin cậy Reliability và tính dư thừa Redundancy Việc để mất mát các files không được phép xảy ra ở trong hệ thống. Do đó, ta cần lưu trữ nhiều bản copies của từng file và do đó nếu storage server dies thì ta vẫn có thể lấy ra được photo từ các bản copy của nó ở những storage server khác.\nĐịnh luật này cũng sẽ được áp dụng cho các thành phần components khác trong hệ thống. Nếu ta muốn hệ thống có tính sẵn sàng cao, chúng ta cần có nhiều bản sao chép replicas của các services đang chạy trong hệ thống do nếu có 1 vài services die thì hệ thống vẫn chạy và đảm bảo sẵn sàng. Tính dư thừa Redundancy sẽ xóa bỏ điểm yếu single point of failure của hệ thống.\nViệc tạo ra dư thừa redundancy trong 1 hệ thống có thể xóa bỏ rủi ro single points of failure và cung cấp khả năng backup hay dự phòng nếu cần khi hệ thống gặp rủi ro. Ví dụ, nếu có 2 instances của cùng 1 service đang chạy trên production và khi 1 cái fail, thì hệ thống có thể chuyển đổi dự phòng failover tới bản copy khỏe mạnh. Failover có thể xảy ra 1 cách tự động và không đòi hỏi bất kỳ sự can thiệp thủ công nào.\n10. Data Sharding Giờ chúng ta sẽ bàng tới các kiểu schemes khác nhau phục vụ cho metadata sharding:\na. Partitioning dựa vào UserID Ta gỉa sử rằng chúng ta sẽ shard dựa trên ‘UserID’ do đó ta có thể giữ mọi photos của 1 user nằm trong cùng 1 shard. Nếu 1 DB shard là 1 TB, chúng ta sẽ cần 4 shards để lưu trữ 3.7TB dữ liệu. Chúng ta sẽ giả sử rằng, vì lí do performace và scalability tốt hơn, ta sẽ cần 10 shards.\nDo vậy ta sẽ tính được shard number bằng cách lấy số dư UserID chia cho 10 và sẽ lưu trữ dữ liệu data trên shard number đó. Để xác định được tính unique của photo trong hệ thống, ta cần thêm thông tin shard number vào sau mỗi PhotoID.\nCách mà ta sẽ tạo ra PhotoIDs? Mỗi DB shard sẽ có riêng cho mình 1 chuỗi tự tăng auto-increment sequence cho PhotoIDs, và do đó ta sẽ thêm ShardID vào sau mỗi PhotoID, ta sẽ khiến nó unique trên toàn hệ thống.\nNhững vấn đề sẽ phát sinh với kiểu phân tán partitioning scheme này?\n Cách mà ta sẽ xử lý đối với hot users? rất nhiều người theo dõi follow những hot users này, và cũng rất nhiều người khác xem những photo mà những user này upload lên. 1 vài users sẽ có rất nhiều photos so với những người khác, do vậy nó sẽ tạo ra sự phấn tán lưu trữ không đồng đều. Chúng ta phải làm gì nếu ta không lưu trữ được tất cả các ảnh của 1 người dùng trên cùng 1 shard? Nếu ta phân tán photos của 1 user ra trên nhiều shards, thì nó có gây ra độ trễ lớn? Việc lưu trữ tất cả các photos của 1 user trên cùng 1 shard có thể gây ra các vấn đề như độ sẵn sàng của tất cả các dữ liệu của user sẽ không truy cập được nếu shard down và độ trễ cao nếu shard nó đang cao tải.  b. Partitioning dựa vào PhotoID Nếu ta có thể tạo ra unique PhotoIDs trước và sau đó xác định shard number dựa vào “PhotoID % 10”, các vấn đề đặt ra ở trên sẽ được giải quyết. Ta cũng không cần thêm thông tin ShardID vào sau PhotoID trong trường hợp này, do PhotoID bản thân nó đã unique trên toàn bộ hệ thống.\nCách mà ta tạo ra PhotoIDs? theo cách này, ta không cần 1 chuỗi tự tăng auto-incrementing sequence ở mỗi shard để định nghĩa PhotoID bởi vì ta cần biết về PhotoID trước để xác định ra shard number mà ta dùng để lưu trữ dữ liệu. 1 giải pháp khác là ta có thể danh riêng 1 database instance để tạo ra các IDs tự tăng auto-incrementing IDs. Nếu PhotoID có thể chứa đủ trong 64 bits, ta có thể định nghĩa 1 table chỉ chứa 64 bit ID field. Do vậy bất cứ khi nào ta thêm 1 photo vào hệ thống, ta có thể thêm mới 1 row mới vào table này và lấy giá trị ID đó làm PhotoID của 1 photo mới.\nhệ thống key generating DB này có phải là 1 single point of failure? Đúng vậy. 1 cách giải quyết cho vấn đề này là ta có thể sử dụng 2 databases, 1 cái chỉ tạo ra các IDs lẻ, và cái còn lại tạo ra IDs chẵn. Ví dụ với MySQL, ta có thể sử dụng scripts sau để định nghĩa chuỗi sequences:\nKeyGeneratingServer1: auto-increment-increment = 2 auto-increment-offset = 1 KeyGeneratingServer2: auto-increment-increment = 2 auto-increment-offset = 2 Ta có thể đặt 1 cân bằng tải load balancer ở trước những databases này để cân bằng tải round-robin giữa chúng và cũng để giải quyết vấn đề downtime. Khi cả 2 servers bị rơi khỏi sự đồng bộ này, thì sẽ naỷ sinh ra trường hợp server này sẽ tạo ra nhiều keys hơn so với cái còn lại, nhưng điều này không gây ra vấn đề gì cho hệ thống. Chúng ta có thể mở rộng cách thiết kế này bằng cách định nghĩa ra các bảng ID dành riêng cho Users, Photo-Comments, hay bất cứ các đố tượng object nào khác mà có trong hệ thống.\nCách chúng ta hoạch định cho việc phát triển của hệ thống trong tương lai? Chúng ta có thể có 1 lượng lớn số phân vùng dữ liệu logical partitions để đáp ứng cho sự phát triển của dữ liệu trong tương lai, giống như thời điểm bắt đầu, có thể có nhiều multiple logical partitions nằm trên cùng 1 database server vật lý. Do mỗi database server có thể có nhiều database instances chạy trên nó, chúng ta có thể có nhiều databases tách biệt nhau trên cùng 1 phân vùng logical partition ở bất cứ server nào. Do đó, bất cứ khi nào ta cảm thấy 1 database server nào đó có nhiều dữ liệu, ta có thể migrate 1 vài phân vùng logical partitions từ nó sang server khác. Ta có thể dựa trên 1 config file (hay config theo từng database riêng biệt) để map phân vùng logical partitions của ta vào các database servers; điều này cho phép ta di chuyển các phân vùng partitions 1 cách dễ dàng. Bất cứ khi nào ta muốn di chuyển 1 phân vùng partition, ta chỉ phải updat lại config file này để tạo ra sự thay đổi.\n11. Cách tạo hệ thống Ranking và News Feed Để tạo ra News Feed cho bất cứ user nào đó, ta cần lấy ra các photos mới nhất, phổ biến nhất, và photos của những người mà user đó đang theo dõi follow.\nĐể đơn giản, ta có thể giả định rằng ta cần lấy ra 100 photos cho 1 News Feed của 1 user. application server của ta cần lấy ra 1 danh sách các người mà user đang theo dõi và lấy ra thông tin metadata info của 100 photos mới nhất của những người này. Bước cuối, server sẽ submit toàn bộ những photos này tới thuật toán ranking của ta, nó sẽ xác định top 100 photos (dựa trên thời điểm xuất hiện, số lượng like) và trả về chúng cho người dùng. 1 vấn đề ta phải đối mặt là độ trễ cao do ta phải truy vấn nhiều tables và thực hiện sorting/merging/ranking trên tập kết quả. Để cải thiện hiệu năng, ta có thể tạo trước sẵn các News Feed và chứa chúng trong 1 bảng table dành riêng.\nCách tạo trước News Feed: Chúng ta có thể dành riêng các servers để liên tục tạo ra các News Feeds của users và sắp xếp chúng trong bảng UserNewsFeed. Do vậy, bất cứ khi nào user cần các photo mới nhất trong News-Feed, chúng ta sẽ đơn giản truy vấn vào bảng table này để trả về kết quả đó cho user.\nBất cứ khi nào các servers này cần tạo ra News Feed cho 1 user, chúng sẽ truy vấn trong bảng UserNewsFeed trước và tìm ra thời điểm tạo gần nhất của News Feed, dựa vào đó News-Feed mới sẽ được tạo từ thời điểm đó trở lại đây.\nCó những cách nào để gửi các News Feed mới cho các users?\n Pull: Clients có thể pull các News-Feed từ server theo 1 khoảng thời gian định kỳ hay thủ công bất cứ khi nào họ cần. Các vấn đề phát sinh với các tiếp cận này: Dữ liệu mới có thể không được hiện thị ra cho users cho tới khi client thực hiện pull request, Đa số thời gian, pull requests sẽ trả về kết quả rỗng nếu chưa có dữ liệu mới. Push: Server có thể push dữ liệu mới xuống users sớm nhất khi chúng vừa xuất hiện. Để quản lý việc này hiệu quả, users phải duy trì 1 Long Poll request tới server để nhận về updates. Vấn đề phát sinh với cách tiếp cận này: 1 user có thể theo dõi rất nhiều người hay 1 user nổi tiếng có thể có hàng triệu người theo dõi; trong trường hợp này, server phải push updates 1 cách liên tục. Hybrid: Chúng ta có thể sử dụng 1 cách lai hybrid. Chúng ta có thể chuyển tất cả các users mà có số lượng lớn người theo dõi thành kiểu pull-based model và chỉ push data với những user chỉ có 1 vài trăm hay 1 vài ngàn người theo dõi. Cách tiếp cận khắc là có thể để server push updates tới tất cả users mà không hoạt động quá thường xuyên và cho phép các user với nhiều updates pull data 1 cách thường xuyên.  12. Cách tạo News Feed với các Sharded Data 1 trong các yêu cầu quan trọng nhất là việc tạo ra News Feed cho bất cứ user nào đó để lấy về các photos mới nhất từ tất cả những ngừời mà user theo dõi. Để làm được điều này, ta cần có 1 cơ chế để sort photos theo thời gian tạo. Để làm việc này 1 cách hiệu quả, ta có thể thêm thời gian tạo photo là 1 phần của PhotoID. Do đó ta chỉ cần đánh khóa chính vào PhotoID, là có thể dễ dàng nhanh chóng tìm ra được các PhotoIDs mới nhất.\nTa có thể sử dụng epoch time cho việc này. Do vậy PhotoID sẽ gồm có 2 phần: phần đầu tiên sẽ biểu diễn epoch time, phần thứ 2 sẽ là 1 chuỗi tự tăng auto-incrementing sequence. Do vậy khi tạo ra 1 PhotoID mới, ta cần lấy ra epoch time hiện tại và thêm nó vào 1 chuỗi tự tăng auto-incrementing ID từ key-generating DB. Ta có thể dễ dàng xác định shard number từ PhotoID ( PhotoID % 10) này và lưu photo này vào shard number đó.\nKích thước PhotoID là bao nhiêu? Nếu epoch time bắt đầu từ thời điểm hiện tại; và ta sẽ cần bao nhiêu bits để lưu trữ số giây cho 50 năm tới?\n86400 sec/day * 365 (days a year) * 50 (years) = 1.6 billion seconds Chúng ta cần 31 bits để lưu trữ số này. Do, ta đang kỳ vọng trung bình có 23 photos mới mỗi giây, ta có thể phải cấp phát thêm 9 bits để lưu trữ chuỗi tự tăng auto-incremented sequence nữa. Do mỗi giây, ta có cần lưu trũ 2^9 = 512 photos mới. Chúng ta đang cấp pháy 9 bits cho chuỗi tự tăng là nhiều hơn những gì mà ta yêu cầu; chúng ta làm việc này bằng cách lấy ra 1 số full byte number (as 40 bits = 5 bytes40bits=5bytes). Ta có thể reset lại chuỗi tự tăng auto-incrementing sequence vào mỗi giây.\n13. Cache và Load balancing Chúng ta cần 1 hệ thống phân phối ảnh có khả năng mở rộng lớn để đáp ứng các users nằm phân tán trên toàn cầu. Hệ thống chỉ nên push các bội dung content gần với user bằng cách sử dụng lượng lớn các photo cache servers được phân tán theo vùng địa lý và sử dụng CDNs.\nChúng ta có thể thêm vào 1 cơ chế cache cho metadata servers để cache lại các hot database rows. Chúng ta có thể sử dụng Memcache để cache data, và Application servers trước khi hit vào database có thể nhanh chóng kiểm tra được cache có chứa dữ liệu mong muốn. Chính sách LRU có thể được áp dụng để xóa cache trong hệ thống của ta. Khi dùng chính sách này, ta sẽ loại bỏ được các row ít được xem trước tiên.\nCách mà ta xây dựng 1 hệ thống cache thông minh hơn? Nếu ta tuân theo định luật 80/20, thì 20% tổng sản lượng read hàng ngày sẽ tạo ra 80% traffic, điều này có nghĩa là 1 vài photos nhất định sẽ trở nên phổ biến và được nhiều người đọc chúng. Điều này cho thấy rằng chúng ta có thể thử lưu vào bộ nhớ đệm 20% khối lượng ảnh và metadata đọc hàng ngày.\n","wordCount":"3855","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"telion"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/"},"publisher":{"@type":"Organization","name":"LifeSucks","logo":{"@type":"ImageObject","url":"https://lifesucks.dev/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://lifesucks.dev/ accesskey=h title="LifeSucks (Alt + H)">LifeSucks</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://lifesucks.dev/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/series/ title=Series>
<span>Series</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://lifesucks.dev/>Home</a>&nbsp;»&nbsp;<a href=https://lifesucks.dev/posts/>Posts</a></div>
<h1 class=post-title>
Bài 4: Cách thiết kế Instagram
</h1>
<div class=post-description>
Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ chia sẻ photo giống như Instagram, nơi mà người dùng users có thể tải lên photos và chia sẻ chúng với những người khác
</div>
<div class=post-meta>19 min&nbsp;·&nbsp;telion&nbsp;|&nbsp;<a href=https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/grokking-system-design-interviews/Designing%20Instagram.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#1-instagram-l%c3%a0-g%c3%ac aria-label="1. Instagram là gì?">1. Instagram là gì?</a></li>
<li>
<a href=#2-y%c3%aau-c%e1%ba%a7u-requirements-v%c3%a0-m%e1%bb%a5c-ti%c3%aau-goals-c%e1%bb%a7a-h%e1%bb%87-th%e1%bb%91ng aria-label="2. Yêu cầu Requirements và mục tiêu Goals của hệ thống">2. Yêu cầu Requirements và mục tiêu Goals của hệ thống</a></li>
<li>
<a href=#3-1-v%c3%a0i-ch%c3%ba-%c3%bd-c%e1%ba%a7n-xem-x%c3%a9t-%c4%91%e1%ba%bfn-khi-th%e1%bb%b1c-hi%e1%bb%87n-thi%e1%ba%bft-k%e1%ba%bf aria-label="3. 1 vài chú ý cần xem xét đến khi thực hiện thiết kế">3. 1 vài chú ý cần xem xét đến khi thực hiện thiết kế</a></li>
<li>
<a href=#4-%c4%91%e1%bb%8bnh-l%c6%b0%e1%bb%a3ng-s%e1%bb%a9c-ch%e1%bb%a9a-capacity-v%c3%a0-c%c3%a1c-r%c3%a0ng-bu%e1%bb%99c-constraints aria-label="4. Định lượng sức chứa Capacity và các ràng buộc Constraints">4. Định lượng sức chứa Capacity và các ràng buộc Constraints</a></li>
<li>
<a href=#5-high-level-system-design aria-label="5. High Level System Design">5. High Level System Design</a></li>
<li>
<a href=#6-database-schema aria-label="6. Database Schema">6. Database Schema</a></li>
<li>
<a href=#7-%c6%b0%e1%bb%9bc-l%c6%b0%e1%bb%a3ng-data-size aria-label="7. Ước lượng Data Size">7. Ước lượng Data Size</a></li>
<li>
<a href=#8-component-design aria-label="8. Component Design">8. Component Design</a></li>
<li>
<a href=#9-%c4%91%e1%bb%99-tin-c%e1%ba%ady-reliability-v%c3%a0-t%c3%adnh-d%c6%b0-th%e1%bb%aba-redundancy aria-label="9. Độ tin cậy Reliability và tính dư thừa Redundancy">9. Độ tin cậy Reliability và tính dư thừa Redundancy</a></li>
<li>
<a href=#10-data-sharding aria-label="10. Data Sharding">10. Data Sharding</a></li>
<li>
<a href=#11-c%c3%a1ch-t%e1%ba%a1o-h%e1%bb%87-th%e1%bb%91ng-ranking-v%c3%a0-news-feed aria-label="11. Cách tạo hệ thống Ranking và News Feed">11. Cách tạo hệ thống Ranking và News Feed</a></li>
<li>
<a href=#12-c%c3%a1ch-t%e1%ba%a1o-news-feed-v%e1%bb%9bi-c%c3%a1c-sharded-data aria-label="12. Cách tạo News Feed với các Sharded Data">12. Cách tạo News Feed với các Sharded Data</a></li>
<li>
<a href=#13-cache-v%c3%a0-load-balancing aria-label="13. Cache và Load balancing">13. Cache và Load balancing</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=1-instagram-là-gì>1. Instagram là gì?<a hidden class=anchor aria-hidden=true href=#1-instagram-là-gì>#</a></h2>
<p>Instagram là 1 dịch vụ mạng xã hội cho phép người dùng users upload và chia sẻ các hình ảnh photos và videos của họ với những người khác. Người dùng Instagram có thể lựa chọn chia sẻ thông thông qua cả 2 hình thức công khai publicly và riêng tư privately. Bất cứ thứ gì được chia sẻ công khai có thể được nhìn thấy bởi người dùng khác, mặt khác những nội dung chia sẻ riêng tư sẽ chỉ được truy cập bởi 1 nhóm người dùng cụ thể. Instagram cho phép người dùng nó chia sẻ thông qua nhiều nền tảng mạng xã hội khác, giống như Facebook, Twitter, Flickr, và Tumblr.</p>
<p>Chúng ta sẽ lên kế hoạch thiết kế 1 phiên bản đơn giản hơn của Instagram vì mục đích thiết kế, nơi mà người dùng user có thể chia sẻ photos và follow những người khác. &ldquo;News Feed&rdquo; cho từng user sẽ chỉ bao gồm các top photos của tất cả gười dùng khác mà user đang follows.</p>
<h2 id=2-yêu-cầu-requirements-và-mục-tiêu-goals-của-hệ-thống>2. Yêu cầu Requirements và mục tiêu Goals của hệ thống<a hidden class=anchor aria-hidden=true href=#2-yêu-cầu-requirements-và-mục-tiêu-goals-của-hệ-thống>#</a></h2>
<p>Chúng ta sẽ tập trung vào các tập yêu cầu như sau khi thực hiện thiết kế Instagram.</p>
<p><strong>Các yêu cầu về mặt tính năng:</strong></p>
<ol>
<li>Users có thể upload/download/view photos.</li>
<li>Users có thể thực hiện các tìm kiếm trên các tiêu đề photo/video.</li>
<li>Users có thể theo dõi follow người khác.</li>
<li>Hệ thống sẽ tạo và hiện thị News Feed của user - Chứa các top photos của tất cả các người dùng mà họ theo dõi.</li>
</ol>
<p><strong>Yêu cầu không liên quan tới tính năng:</strong></p>
<ol>
<li>Hệ thống cần có tính sẵn sàng cao.</li>
<li>Độ trễ có thể chấp nhận được của hệ thống là 200ms cho việc tạo ra News Feed.</li>
<li>Hệ thống chấp nhận tính nhất quán có thể ảnh hưởng nếu người dùng không nhìn thấy 1 photo trong 1 khoảng thời gian.</li>
<li>Hệ thống có độ tin cậy cao, bất cứ photo hay video nào đã được upload thì sẽ không bao giờ bị mất.</li>
</ol>
<p><strong>Không nằm trong scope:</strong> Việc theo tags vào photos, tìm kiếm photos dựa trên tag, bình luận vào photos, tagging người dùng user vào photos, etc.</p>
<h2 id=3-1-vài-chú-ý-cần-xem-xét-đến-khi-thực-hiện-thiết-kế>3. 1 vài chú ý cần xem xét đến khi thực hiện thiết kế<a hidden class=anchor aria-hidden=true href=#3-1-vài-chú-ý-cần-xem-xét-đến-khi-thực-hiện-thiết-kế>#</a></h2>
<p>Hệ thống sẽ nặng tải về read, do vậy ta sẽ tập trung vào xây dựng 1 hệ thống sao cho việc lấy ra các photos 1 cách nhanh nhất.</p>
<ol>
<li>Thực tế, users có thể upload bao nhiêu photos tùy thích, do vậy việc quản lý lưu trữ storage 1 cách hiệu quả sẽ là 1 nhân tố đóng vai trò quan trọng trong thiết kế hệ thống.</li>
<li>Độ trễ thấp như kỳ vọng khi thực hiện viewing photos.</li>
<li>Data cũng cần 100% tin cậy. Nếu 1 user upload 1 photo thì hệ thống sẽ đảm bảo nó sẽ không bao giờ bị mất.</li>
</ol>
<h2 id=4-định-lượng-sức-chứa-capacity-và-các-ràng-buộc-constraints>4. Định lượng sức chứa Capacity và các ràng buộc Constraints<a hidden class=anchor aria-hidden=true href=#4-định-lượng-sức-chứa-capacity-và-các-ràng-buộc-constraints>#</a></h2>
<ul>
<li>Ta giả sử chúng ra có tổng số 500M users, với 1M user hoạt động hàng ngày.</li>
<li>2M photos mới được tạo ra mỗi ngày, 23 new photos mỗi giây.</li>
<li>Trung bình kích thước 1 photo => 200KB.</li>
<li>Tổng số lưu trữ bắt buộc cho tất cả photos trong 1 ngày là: <code>2M * 200KB => 400 GB</code></li>
<li>Tổng số lưu trữ bắt buộc cho tất cả photos trong 10 năm là: <code>400GB *365 (days a year)* 10 (years) ~= 1425TB</code></li>
</ul>
<h2 id=5-high-level-system-design>5. High Level System Design<a hidden class=anchor aria-hidden=true href=#5-high-level-system-design>#</a></h2>
<p>Ở mức high-level, chúng ta cần support 2 ngữ cảnh, 1 là thực hiện upload photos, 2 là khi thực hiện view/search photos. Do đó dịch vụ chúng ta thiết kế sẽ cần các object storage servers để lưu tữ photos và database servers để lưu trữ các thông tin metadata của photos.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/5506715794014208.svg alt="High-level design diagram" title="High-level design diagram">
</p>
<h2 id=6-database-schema>6. Database Schema<a hidden class=anchor aria-hidden=true href=#6-database-schema>#</a></h2>
<blockquote>
<p>Việc định nghiã DB schema ở những giai đoạn đầu tiên của cuộc phỏng vấn sẽ giúp mọi người hiểu về luồng data flow giữa các thành phần components khác nhau trong hệ thống và giúp định hướng cách phân vùng dữ liệu data partitioning sau này.</p>
</blockquote>
<p>Chúng ta cần lưu trữ dữ liệu về users, các photos được upload lên bởi họ, những người họ đang theo dõi follow. bảng Photo sẽ chứa tất cả các dữ liệu liên quan tới ảnh photo; chúng ta cần đánh index trên cặp (PhotoID, CreationDate) do ta cần lấy ra những photo được upload lên gần đây trước tiên.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/4843868239953920.svg alt="Database Schema" title="Database Schema">
</p>
<p>1 cách tiếp cận hết sức hiển nhiên cho việc lưu trữ giống như database schema ở trên là sử dụng 1 RDBMS như MySQL do ta có sử dụng đến joins. Nhưng databases quan hệ cũng đi cùng những thách thức của chúng, đặc biệt là khi ta cần mở rộng scale chúng.</p>
<p>Chúng ta có thể lưu trữ photos ở những hệ thống lưu trữ phân tán file distributed file storage giống như HDFS hay S3.</p>
<p>Chúng ta có thể lưu trữ dữ liệu ở schema trên dưới dạng lưu trữ phân tán distributed key-value để tận dựng được các ưu điểm của NoSQL. Tất cả các thông tin metadata liên quan tới photos lưu trữ trong 1 table mà có key là &lsquo;PhotoID&rsquo; và value sẽ la 1 object chứa các thông tin PhotoLocation, UserLocation, CreationTimestamp, etc.</p>
<p>Nếu chúng ta chọn giải pháp sử dụng 1 NoSQL database, chúng ta cần thêm 1 table nữa để lưu trữ quan hệ relationships giữa users và photos để biết được ai đang sở hữu photo nào. Chúng ta sẽ gọi bảng này là &lsquo;UserPhoto&rsquo;. Chúng ta cũng cần lưu trữ danh sách các người mà 1 user đang theo dõi follow. Chúng ta gọi bảng này là &lsquo;UserFollow&rsquo;. Với những bảng table dạng này, ta có thể sử dụng 1 kiểu wide-column datastore giống như Cassandra. Ví với bảng UserPhoto, với key là UserID và value là danh sách các PhotoIDs mà user sở hữu, được lưu trữ ở các cột columns khác nhau. Chúng ta sẽ có schema tương tự cho bảng UserFollow.</p>
<p>Cassandra hay các kiểu key-value stores, thông thường luôn duy trì 1 số lượng các bản sao replicas để đảm bảo tính sẵn sàng của hệ thống. Và cũng ở trong những data stores dạng này, việc xóa deletes sẽ không được áp dụng ngay lập tức; dữ liệu data sẽ vẫn còn được lưu trữ trong vài ngày (hỗ trợ trường hợp muốn undeleting) trước khi bị xóa vĩnh viễn khỏi hệ thống.</p>
<h2 id=7-ước-lượng-data-size>7. Ước lượng Data Size<a hidden class=anchor aria-hidden=true href=#7-ước-lượng-data-size>#</a></h2>
<p>Chúng ta sẽ ước lượng cách mà dữ liệu data sẽ gia tăng ở từng bảng table và tổng số lưu trữ storage mà ta cần lưu trữ trong 10 năm.</p>
<p><strong>User:</strong> Giả sử rằng mỗi kiểu dữ liệu &lsquo;int&rsquo; và &lsquo;dataTime&rsquo; cần 4 bytes để lưu trữ, mỗi dòng row trong bảng User sẽ cần 68 bytes:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>UserID <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + Name <span style=color:#f92672>(</span><span style=color:#ae81ff>20</span> bytes<span style=color:#f92672>)</span> + Email <span style=color:#f92672>(</span><span style=color:#ae81ff>32</span> bytes<span style=color:#f92672>)</span> + DateOfBirth <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + CreationDate <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + LastLogin <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>68</span> bytes
</code></pre></div><p>Nếu chúng ta có 500M users, thì ta sẽ cần 32GB để lưu trữ:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>500</span> million * <span style=color:#ae81ff>68</span> ~<span style=color:#f92672>=</span> 32GB
</code></pre></div><p><strong>Photo:</strong> Mỗi row trong bảng Photo sẽ cần 284 bytes:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>PhotoID <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + UserID <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + PhotoPath <span style=color:#f92672>(</span><span style=color:#ae81ff>256</span> bytes<span style=color:#f92672>)</span> + PhotoLatitude <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + PhotoLongitude<span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + UserLatitude <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + UserLongitude <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> + CreationDate <span style=color:#f92672>(</span><span style=color:#ae81ff>4</span> bytes<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>284</span> bytes
</code></pre></div><p>Nếu có 2M photos mới được upload mỗi ngày, chúng ta sẽ cần 0.5GB lưu trữ cho mỗi ngày:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>2M * <span style=color:#ae81ff>284</span> bytes ~<span style=color:#f92672>=</span> 0.5GB per day
</code></pre></div><p>Với 10 năm, ta sẽ cần 1.88TB lưu trữ.</p>
<p><strong>UserFollow:</strong> Mỗi row trong UserFollow sẽ cần 8 bytes. Nếu ta có 500M users và trung bình mỗi user sẽ thực hiện theo dõi follow 500 người khác. Chúng ta sẽ cần 1.82TB lưu trữ cho UserFollow:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>500</span> million users * <span style=color:#ae81ff>500</span> followers * <span style=color:#ae81ff>8</span> bytes ~<span style=color:#f92672>=</span> 1.82TB
</code></pre></div><p>Tổng dung lượng cần để lưu trữ tất cả các tables trong vòng 10 năm sẽ là 3.7TB:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>32GB + 1.88TB + 1.82TB ~<span style=color:#f92672>=</span> 3.7TB
</code></pre></div><h2 id=8-component-design>8. Component Design<a hidden class=anchor aria-hidden=true href=#8-component-design>#</a></h2>
<p>Việc photo được upload (hay write) có thể trở nên chậm nếu chúng được ghi trực tiếp vào ổ disk, trong khi việc đọc reads sẽ nhanh hơn, đặc biệt nếu chúng được đọc từ cache.</p>
<p>Những người dùng thực hiện upload có thể sử dụng hết các connections hiện có của hệ thống, do việc thực hiện uploading được xét là 1 slow process. Điều này có nghĩa là reads có thể bị ảnh hưởng nếu hệ thống bị quá tải với các write request. Chúng ta cũng cần lưu ý rằng 1 web server luôn có 1 ngưỡng giới hạn connection limit. Ta giả sử rằng web server có 1 ngưỡng giới hạn là 500 connections tại 1 thời điểm, thì nó không thể có hơn 500 uploads hay reads cùng lúc. Để khắc phục nghẽn cổ chai này, ta có thể phân chia reads và writes vào các serivces độc lập. Chúng ta sẽ có các servers dành riêng cho việc reads và các server khác dành riêng cho việc writes để đảm bảo việc upload không ảnh hưởng tới cả hệ thống.</p>
<p>Việc tách biệt read và write requests cũng cho phép ta mở rộng và tối ưu từng loại xử lý 1 cách độc lập:</p>
<p><img loading=lazy src=/grokking-system-design-interviews/4843868239953920.svg alt="Component Design" title="Component Design">
</p>
<h2 id=9-độ-tin-cậy-reliability-và-tính-dư-thừa-redundancy>9. Độ tin cậy Reliability và tính dư thừa Redundancy<a hidden class=anchor aria-hidden=true href=#9-độ-tin-cậy-reliability-và-tính-dư-thừa-redundancy>#</a></h2>
<p>Việc để mất mát các files không được phép xảy ra ở trong hệ thống. Do đó, ta cần lưu trữ nhiều bản copies của từng file và do đó nếu storage server dies thì ta vẫn có thể lấy ra được photo từ các bản copy của nó ở những storage server khác.</p>
<p>Định luật này cũng sẽ được áp dụng cho các thành phần components khác trong hệ thống. Nếu ta muốn hệ thống có tính sẵn sàng cao, chúng ta cần có nhiều bản sao chép replicas của các services đang chạy trong hệ thống do nếu có 1 vài services die thì hệ thống vẫn chạy và đảm bảo sẵn sàng. Tính dư thừa Redundancy sẽ xóa bỏ điểm yếu single point of failure của hệ thống.</p>
<p>Việc tạo ra dư thừa redundancy trong 1 hệ thống có thể xóa bỏ rủi ro single points of failure và cung cấp khả năng backup hay dự phòng nếu cần khi hệ thống gặp rủi ro. Ví dụ, nếu có 2 instances của cùng 1 service đang chạy trên production và khi 1 cái fail, thì hệ thống có thể chuyển đổi dự phòng failover tới bản copy khỏe mạnh. Failover có thể xảy ra 1 cách tự động và không đòi hỏi bất kỳ sự can thiệp thủ công nào.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/5399792583180288.svg alt="Reliability and Redundancy" title="Reliability and Redundancy">
</p>
<h2 id=10-data-sharding>10. Data Sharding<a hidden class=anchor aria-hidden=true href=#10-data-sharding>#</a></h2>
<p>Giờ chúng ta sẽ bàng tới các kiểu schemes khác nhau phục vụ cho metadata sharding:</p>
<p><strong>a. Partitioning dựa vào UserID</strong> Ta gỉa sử rằng chúng ta sẽ shard dựa trên &lsquo;UserID&rsquo; do đó ta có thể giữ mọi photos của 1 user nằm trong cùng 1 shard. Nếu 1 DB shard là 1 TB, chúng ta sẽ cần 4 shards để lưu trữ 3.7TB dữ liệu. Chúng ta sẽ giả sử rằng, vì lí do performace và scalability tốt hơn, ta sẽ cần 10 shards.</p>
<p>Do vậy ta sẽ tính được shard number bằng cách lấy số dư UserID chia cho 10 và sẽ lưu trữ dữ liệu data trên shard number đó. Để xác định được tính unique của photo trong hệ thống, ta cần thêm thông tin shard number vào sau mỗi PhotoID.</p>
<p><strong>Cách mà ta sẽ tạo ra PhotoIDs?</strong> Mỗi DB shard sẽ có riêng cho mình 1 chuỗi tự tăng auto-increment sequence cho PhotoIDs, và do đó ta sẽ thêm ShardID vào sau mỗi PhotoID, ta sẽ khiến nó unique trên toàn hệ thống.</p>
<p><strong>Những vấn đề sẽ phát sinh với kiểu phân tán partitioning scheme này?</strong></p>
<ol>
<li>Cách mà ta sẽ xử lý đối với hot users? rất nhiều người theo dõi follow những hot users này, và cũng rất nhiều người khác xem những photo mà những user này upload lên.</li>
<li>1 vài users sẽ có rất nhiều photos so với những người khác, do vậy nó sẽ tạo ra sự phấn tán lưu trữ không đồng đều.</li>
<li>Chúng ta phải làm gì nếu ta không lưu trữ được tất cả các ảnh của 1 người dùng trên cùng 1 shard? Nếu ta phân tán photos của 1 user ra trên nhiều shards, thì nó có gây ra độ trễ lớn?</li>
<li>Việc lưu trữ tất cả các photos của 1 user trên cùng 1 shard có thể gây ra các vấn đề như độ sẵn sàng của tất cả các dữ liệu của user sẽ không truy cập được nếu shard down và độ trễ cao nếu shard nó đang cao tải.</li>
</ol>
<p><strong>b. Partitioning dựa vào PhotoID</strong> Nếu ta có thể tạo ra unique PhotoIDs trước và sau đó xác định shard number dựa vào “PhotoID % 10”, các vấn đề đặt ra ở trên sẽ được giải quyết. Ta cũng không cần thêm thông tin ShardID vào sau PhotoID trong trường hợp này, do PhotoID bản thân nó đã unique trên toàn bộ hệ thống.</p>
<p><strong>Cách mà ta tạo ra PhotoIDs?</strong> theo cách này, ta không cần 1 chuỗi tự tăng auto-incrementing sequence ở mỗi shard để định nghĩa PhotoID bởi vì ta cần biết về PhotoID trước để xác định ra shard number mà ta dùng để lưu trữ dữ liệu. 1 giải pháp khác là ta có thể danh riêng 1 database instance để tạo ra các IDs tự tăng auto-incrementing IDs. Nếu PhotoID có thể chứa đủ trong 64 bits, ta có thể định nghĩa 1 table chỉ chứa 64 bit ID field. Do vậy bất cứ khi nào ta thêm 1 photo vào hệ thống, ta có thể thêm mới 1 row mới vào table này và lấy giá trị ID đó làm PhotoID của 1 photo mới.</p>
<p><strong>hệ thống key generating DB này có phải là 1 single point of failure?</strong> Đúng vậy. 1 cách giải quyết cho vấn đề này là ta có thể sử dụng 2 databases, 1 cái chỉ tạo ra các IDs lẻ, và cái còn lại tạo ra IDs chẵn. Ví dụ với MySQL, ta có thể sử dụng scripts sau để định nghĩa chuỗi sequences:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>KeyGeneratingServer1:
auto-increment-increment <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
auto-increment-offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>

KeyGeneratingServer2:
auto-increment-increment <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
auto-increment-offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</code></pre></div><p>Ta có thể đặt 1 cân bằng tải load balancer ở trước những databases này để cân bằng tải round-robin giữa chúng và cũng để giải quyết vấn đề downtime. Khi cả 2 servers bị rơi khỏi sự đồng bộ này, thì sẽ naỷ sinh ra trường hợp server này sẽ tạo ra nhiều keys hơn so với cái còn lại, nhưng điều này không gây ra vấn đề gì cho hệ thống. Chúng ta có thể mở rộng cách thiết kế này bằng cách định nghĩa ra các bảng ID dành riêng cho Users, Photo-Comments, hay bất cứ các đố tượng object nào khác mà có trong hệ thống.</p>
<p><strong>Cách chúng ta hoạch định cho việc phát triển của hệ thống trong tương lai?</strong> Chúng ta có thể có 1 lượng lớn số phân vùng dữ liệu logical partitions để đáp ứng cho sự phát triển của dữ liệu trong tương lai, giống như thời điểm bắt đầu, có thể có nhiều multiple logical partitions nằm trên cùng 1 database server vật lý. Do mỗi database server có thể có nhiều database instances chạy trên nó, chúng ta có thể có nhiều databases tách biệt nhau trên cùng 1 phân vùng logical partition ở bất cứ server nào. Do đó, bất cứ khi nào ta cảm thấy 1 database server nào đó có nhiều dữ liệu, ta có thể migrate 1 vài phân vùng logical partitions từ nó sang server khác. Ta có thể dựa trên 1 config file (hay config theo từng database riêng biệt) để map phân vùng logical partitions của ta vào các database servers; điều này cho phép ta di chuyển các phân vùng partitions 1 cách dễ dàng. Bất cứ khi nào ta muốn di chuyển 1 phân vùng partition, ta chỉ phải updat lại config file này để tạo ra sự thay đổi.</p>
<h2 id=11-cách-tạo-hệ-thống-ranking-và-news-feed>11. Cách tạo hệ thống Ranking và News Feed<a hidden class=anchor aria-hidden=true href=#11-cách-tạo-hệ-thống-ranking-và-news-feed>#</a></h2>
<p>Để tạo ra News Feed cho bất cứ user nào đó, ta cần lấy ra các photos mới nhất, phổ biến nhất, và photos của những người mà user đó đang theo dõi follow.</p>
<p>Để đơn giản, ta có thể giả định rằng ta cần lấy ra 100 photos cho 1 News Feed của 1 user. application server của ta cần lấy ra 1 danh sách các người mà user đang theo dõi và lấy ra thông tin metadata info của 100 photos mới nhất của những người này. Bước cuối, server sẽ submit toàn bộ những photos này tới thuật toán ranking của ta, nó sẽ xác định top 100 photos (dựa trên thời điểm xuất hiện, số lượng like) và trả về chúng cho người dùng. 1 vấn đề ta phải đối mặt là độ trễ cao do ta phải truy vấn nhiều tables và thực hiện sorting/merging/ranking trên tập kết quả. Để cải thiện hiệu năng, ta có thể tạo trước sẵn các News Feed và chứa chúng trong 1 bảng table dành riêng.</p>
<p><strong>Cách tạo trước News Feed:</strong> Chúng ta có thể dành riêng các servers để liên tục tạo ra các News Feeds của users và sắp xếp chúng trong bảng UserNewsFeed. Do vậy, bất cứ khi nào user cần các photo mới nhất trong News-Feed, chúng ta sẽ đơn giản truy vấn vào bảng table này để trả về kết quả đó cho user.</p>
<p>Bất cứ khi nào các servers này cần tạo ra News Feed cho 1 user, chúng sẽ truy vấn trong bảng UserNewsFeed trước và tìm ra thời điểm tạo gần nhất của News Feed, dựa vào đó News-Feed mới sẽ được tạo từ thời điểm đó trở lại đây.</p>
<p><strong>Có những cách nào để gửi các News Feed mới cho các users?</strong></p>
<ol>
<li><strong>Pull:</strong> Clients có thể pull các News-Feed từ server theo 1 khoảng thời gian định kỳ hay thủ công bất cứ khi nào họ cần. Các vấn đề phát sinh với các tiếp cận này: Dữ liệu mới có thể không được hiện thị ra cho users cho tới khi client thực hiện pull request, Đa số thời gian, pull requests sẽ trả về kết quả rỗng nếu chưa có dữ liệu mới.</li>
<li><strong>Push:</strong> Server có thể push dữ liệu mới xuống users sớm nhất khi chúng vừa xuất hiện. Để quản lý việc này hiệu quả, users phải duy trì 1 Long Poll request tới server để nhận về updates. Vấn đề phát sinh với cách tiếp cận này: 1 user có thể theo dõi rất nhiều người hay 1 user nổi tiếng có thể có hàng triệu người theo dõi; trong trường hợp này, server phải push updates 1 cách liên tục.</li>
<li><strong>Hybrid:</strong> Chúng ta có thể sử dụng 1 cách lai hybrid. Chúng ta có thể chuyển tất cả các users mà có số lượng lớn người theo dõi thành kiểu pull-based model và chỉ push data với những user chỉ có 1 vài trăm hay 1 vài ngàn người theo dõi. Cách tiếp cận khắc là có thể để server push updates tới tất cả users mà không hoạt động quá thường xuyên và cho phép các user với nhiều updates pull data 1 cách thường xuyên.</li>
</ol>
<h2 id=12-cách-tạo-news-feed-với-các-sharded-data>12. Cách tạo News Feed với các Sharded Data<a hidden class=anchor aria-hidden=true href=#12-cách-tạo-news-feed-với-các-sharded-data>#</a></h2>
<p>1 trong các yêu cầu quan trọng nhất là việc tạo ra News Feed cho bất cứ user nào đó để lấy về các photos mới nhất từ tất cả những ngừời mà user theo dõi. Để làm được điều này, ta cần có 1 cơ chế để sort photos theo thời gian tạo. Để làm việc này 1 cách hiệu quả, ta có thể thêm thời gian tạo photo là 1 phần của PhotoID. Do đó ta chỉ cần đánh khóa chính vào PhotoID, là có thể dễ dàng nhanh chóng tìm ra được các PhotoIDs mới nhất.</p>
<p>Ta có thể sử dụng epoch time cho việc này. Do vậy PhotoID sẽ gồm có 2 phần: phần đầu tiên sẽ biểu diễn epoch time, phần thứ 2 sẽ là 1 chuỗi tự tăng auto-incrementing sequence. Do vậy khi tạo ra 1 PhotoID mới, ta cần lấy ra epoch time hiện tại và thêm nó vào 1 chuỗi tự tăng auto-incrementing ID từ key-generating DB. Ta có thể dễ dàng xác định shard number từ PhotoID ( PhotoID % 10) này và lưu photo này vào shard number đó.</p>
<p><strong>Kích thước PhotoID là bao nhiêu?</strong> Nếu epoch time bắt đầu từ thời điểm hiện tại; và ta sẽ cần bao nhiêu bits để lưu trữ số giây cho 50 năm tới?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>86400</span> sec/day * <span style=color:#ae81ff>365</span> <span style=color:#f92672>(</span>days a year<span style=color:#f92672>)</span> * <span style=color:#ae81ff>50</span> <span style=color:#f92672>(</span>years<span style=color:#f92672>)</span> <span style=color:#f92672>=</span>&gt; 1.6 billion seconds
</code></pre></div><p>Chúng ta cần 31 bits để lưu trữ số này. Do, ta đang kỳ vọng trung bình có 23 photos mới mỗi giây, ta có thể phải cấp phát thêm 9 bits để lưu trữ chuỗi tự tăng auto-incremented sequence nữa. Do mỗi giây, ta có cần lưu trũ 2^9 = 512 photos mới. Chúng ta đang cấp pháy 9 bits cho chuỗi tự tăng là nhiều hơn những gì mà ta yêu cầu; chúng ta làm việc này bằng cách lấy ra 1 số full byte number (as 40 bits = 5 bytes40bits=5bytes). Ta có thể reset lại chuỗi tự tăng auto-incrementing sequence vào mỗi giây.</p>
<h2 id=13-cache-và-load-balancing>13. Cache và Load balancing<a hidden class=anchor aria-hidden=true href=#13-cache-và-load-balancing>#</a></h2>
<p>Chúng ta cần 1 hệ thống phân phối ảnh có khả năng mở rộng lớn để đáp ứng các users nằm phân tán trên toàn cầu. Hệ thống chỉ nên push các bội dung content gần với user bằng cách sử dụng lượng lớn các photo cache servers được phân tán theo vùng địa lý và sử dụng CDNs.</p>
<p>Chúng ta có thể thêm vào 1 cơ chế cache cho metadata servers để cache lại các hot database rows. Chúng ta có thể sử dụng Memcache để cache data, và Application servers trước khi hit vào database có thể nhanh chóng kiểm tra được cache có chứa dữ liệu mong muốn. Chính sách LRU có thể được áp dụng để xóa cache trong hệ thống của ta. Khi dùng chính sách này, ta sẽ loại bỏ được các row ít được xem trước tiên.</p>
<p><strong>Cách mà ta xây dựng 1 hệ thống cache thông minh hơn?</strong> Nếu ta tuân theo định luật 80/20, thì 20% tổng sản lượng read hàng ngày sẽ tạo ra 80% traffic, điều này có nghĩa là 1 vài photos nhất định sẽ trở nên phổ biến và được nhiều người đọc chúng. Điều này cho thấy rằng chúng ta có thể thử lưu vào bộ nhớ đệm 20% khối lượng ảnh và metadata đọc hàng ngày.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://lifesucks.dev/tags/system-design-interviews/>system design interviews</a></li>
<li><a href=https://lifesucks.dev/tags/design-photo-sharing-service/>Design photo-sharing service</a></li>
<li><a href=https://lifesucks.dev/tags/design-instagram/>Design Instagram</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/>
<span class=title>« Prev Page</span>
<br>
<span>Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on twitter" href="https://twitter.com/intent/tweet/?text=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f&hashtags=systemdesigninterviews%2cDesignphoto-sharingservice%2cDesignInstagram"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f&title=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram&summary=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram&source=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f&title=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on whatsapp" href="https://api.whatsapp.com/send?text=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram%20-%20https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 4: Cách thiết kế  Instagram on telegram" href="https://telegram.me/share/url?text=B%c3%a0i%204%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Instagram&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-instagram%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://lifesucks.dev/>LifeSucks</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>