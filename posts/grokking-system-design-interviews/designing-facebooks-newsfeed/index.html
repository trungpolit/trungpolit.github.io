<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Bài 13: Cách thiết kế Facebook Newsfeed | LifeSucks</title>
<meta name=keywords content="system design interviews,Designing Facebook’s Newsfeed,Designing Twitter Newsfeed,Designing Instagram Newsfeed,Designing Quora Newsfeed">
<meta name=description content="Chúng ta sẽ cùng nhau thiết kế  Facebook Newsfeed">
<meta name=author content="telion">
<link rel=canonical href=https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lifesucks.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://lifesucks.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://lifesucks.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://lifesucks.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://lifesucks.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet type=text/css href=https://lifesucks.dev/css/custom.css>
<meta property="og:title" content="Bài 13: Cách thiết kế  Facebook Newsfeed">
<meta property="og:description" content="Chúng ta sẽ cùng nhau thiết kế  Facebook Newsfeed">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/"><meta property="og:image" content="https://lifesucks.dev/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/"><meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/"><meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://lifesucks.dev/papermod-cover.png">
<meta name=twitter:title content="Bài 13: Cách thiết kế  Facebook Newsfeed">
<meta name=twitter:description content="Chúng ta sẽ cùng nhau thiết kế  Facebook Newsfeed">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifesucks.dev/posts/"},{"@type":"ListItem","position":2,"name":"Bài 13: Cách thiết kế  Facebook Newsfeed","item":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bài 13: Cách thiết kế  Facebook Newsfeed","name":"Bài 13: Cách thiết kế  Facebook Newsfeed","description":"Chúng ta sẽ cùng nhau thiết kế  Facebook Newsfeed","keywords":["system design interviews","Designing Facebook’s Newsfeed","Designing Twitter Newsfeed","Designing Instagram Newsfeed","Designing Quora Newsfeed"],"articleBody":"1. Facebook newsfeed là gì? 1 Newsfeed là 1 danh sách các bài stories được cập nhật liên tục nằm chính giữa trang Facebook’s homepage. Nó bao gồm các cập nhật liên quan tới trạng thái status, photos, videos, links, app activity hay các likes từ những người, trang pages, hay groups mà người dùng user theo dõi follow trên Facebook.\nVới bất cứ hệ thống mạng xã hội nào mà bạn thiết kế như Twitter, Instagram, hay Facebook thì bạn sẽ cần 1 hệ thống kiểu Newsfeed để hiện thị các thông tin cập nhật từ những người bạn và những người mà bạn theo dõi.\n2. Yêu cầu Requirements và mục tiêu Goals của hệ thống Chúng ta sẽ thiết kế 1 hệ thống newsfeed cho Facebook theo các yêu cầu sau:\nYêu cầu về mặt tính năng:\n Newsfeed cần được tạo ra dựa trên các bài posts từ những người, trang pages, groups mà người dùng user theo dõi follow. 1 người dùng user có thể có rất nhiều bạn và theo dõi follow 1 lượng lớn các pages/groups. Feeds có thể chứ images, videos, hay chỉ chứa text. Hệ thống của chúng ta cần hỗ trợ thêm mới các bài posts mới nhanh nhất có thể khi chúng vừa mới xuất hiện cho tất cả các users đang hoạt động.  Yêu cầu không liên quan tới tính năng:\n Hệ thống có khả năng tạo ra newsfeed cho bất cứ user nào 1 cách real-time và độ trễ tối đa là 2s. 1 bài post không cần tới 5s để nó xuất hiện trong feed của 1 user giả định là bài post vừa được đăng.  3. Ước lượng trữ lượng và các ràng buộc Ta giả định 1 user trung bình sẽ có 300 bạn và theo dõi 200 pages.\nƯớc lượng về traffic: Giả sử ta có 300M người dùng hoạt động hàng ngày và trung bình mỗi người dùng sẽ làm mới timeline của họ 5 lần 1 ngày. Kết quả là sẽ có 1.5B newsfeed request 1 ngày và xấp xỉ 17,500 request mỗi giây.\nƯớc lượng về storage: Ở mức trung bình, ta giả định chúng ta có khoảng 500 posts trên mọi newsfeed của mỗi user và chúng ta sẽ giữ chúng trong bộ nhớ memory để lấy chúng ra 1 cách nhanh nhất. Chúng ta cũng giả định rằng trung bình mỗi bài post có kích thước khoảng 1KB. Điều này có nghĩa rằng chúng ta cần lưu trữ khoảng 500KB dữ liệu data trên mỗi user. Để lưu trữ được tất cả data cho tất cả các users đang active chúng ta cần 150TB memory. Nếu 1 server có thể đáp ứng được 100GB thì chúng ta cần khoảng 1500 servers để giữ được 500 bài posts mới nhất trong memory cho tất cả các users đang active.\n4. System APIs  Khi ta đã chốt được các yêu cầu requirements, thì ý tưởng tốt là định nghĩa các system APIs. Điều này sẽ phản ánh đúng những gì mà hệ thống kì vọng.\n Chúng ta cần có SOAP hay REST APIs để expose ra các tính năng của các service. Đoạn ví dụ dưới dùng để định nghĩa API dùng để lấy ra newsfeed:\ngetUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies) Các tham số:\n api_dev_key (string): Api developer key cần phải được đăng ký để sử dụng và dùng để throttle users dựa trên hạn mức quota mà họ được cấp. user_id (number): ID của user mà hệ thống dùng để tạo newsfeed. since_id (number): Không bắt buộc, trả về kết quả với 1 ID cao hơn (mới hơn) ID cho trước. count (number): Không bắt buộc, định nghĩa số lượng các feed items cần lấy ra, giới hạn max là 200. max_id (number): Không bắt buộc, trả về kết quả với 1 ID nhỏ hơn hoặc bằng (cũ hơn) ID cho trước. exclude_replies(boolean): Không bắt buộc, Tham số này sẽ ngăn chặn việc trả về các replies xuất hiện trong kết quả timeline được trả về.  Kết quả trả về: (JSON) trả về 1 JSON object chứa 1 danh sách các feed items.\n5. Database Design Ta sẽ có 3 đối tượng objects chính: User, Entity (e.g. page, group, etc.), and FeedItem (or Post). Dưới đây là 1 vài quan sát về quan hệ relationships giữa các đối tượng này:\n 1 user có thể follow các đối tượng entities khác và có thể là bạn với users khác. Cả users và các đối tượng entities có thể post FeedItems chứa text, images hay videos. Mỗi FeedItem sẽ có 1 UserID dùng để xác định User tạo ra nó. Cho đơn giản, ta giả định chỉ có users mới tạo được feed items mặc dù Facebook Pages cũng có thể tạo ra. Mỗi FeedItem có thể có 1 EntityID dùng để trỏ tới trang page hay group mà bài posts được tạo ra.  Nếu ta đang sử dụng 1 relational database, chúng ta sẽ cần mô hình hóa 2 mối quan hệ relations: User-Entity relation và FeedItem-Media relation. Do mỗi user có thể là bạn với nhiều người khác và theo dõi follow rất nhiều đối tượng entities, ta có thể lưu trữ mối quan hệ relation ra thành bảng table riêng. cột “Type” trong bảng “UserFollow” dùng để xác định đối tượng entity đang được follow là 1 User hay Entity. Tương tự ta cũng cần có 1 bảng table cho FeedMedia relation.\n6. High Level System Design Ở mức high level, vấn đề của chúng ta chia làm 2 phần:\nFeed generation: Newsfeed được tạo từ các bài posts (hay feed items) từ những users hay entities (pages hay groups) mà 1 user theo dõi. Do đó, bất cứ khi nào hệ thống nhận được yêu cầu tạo feed cho 1 user (ví dụ là Jane), thì chúng ta sẽ thực hiện các bước sau:\n Lấy về IDs của tất cả các users và entities mà Jane theo dõi. Lấy về các bài posts mới nhất, phổ biến nhất, phù hợp nhất cho những IDs này. Đây là posts tiềm năng mà ta có thể hiện thị chúng trong newsfeed của Jane. Đánh giá các bài posts này dựa trên sự phù hợp với Jane. Điều này phản ánh trực tiếp với feed của Jane hiện tại. Lưu trữ feed này vào trong cache và trả về top các bài posts (tầm 20) để hiện thị trong Jane feed. Ở phía front-end, khi Jane chạm tới cuối feed hiện tại của cô ấy, thì cô ấy có thể lấy về tiếp 20 posts tiếp theo từ server và cứ tiếp tục như vậy.  Feed publishing: Bất cứ khi nào Jane load trang newsfeed page của cô ấy, cô ấy phải thực hiện request và pull các feed items từ server. Bất cứ khi nào cô ấy chạm vào đáy của feed hiện tại, thì cô ấy có thể pull data mới từ server. Với những phần tử items mới hơn thì server có thể thông báo cho Jane và cô ấy có thể pull hay server có thể push những posts mới này xuống. Chúng ta sẽ bàn về các lựa chọn này sau.\nỞ mức high level, chúng ta chỉ cần các components sau trong Newsfeed service:\n Web servers: Cần duy trì 1 connection với user. Connection này có thể được sử dụng để chuyển dữ liệu data giữa user và server. Application server: Thực hiện xử lý các luồng nghiệp vụ workflows dùng để lưu trữ các posts mới trong database servers. Chúng ta sẽ cần 1 vài application servers để lấy về và để push newsfeed xuống end user. Metadata database and cache: Dùng để lưu trữ các thông tin metadata liên quan tới Users, Pages, Groups. Posts database and cache: Dùng để lưu trữ các thông tin metadata liên quan tới posts và các nội dung contents của họ. Video and photo storage, and cache: Dạng blob storage, dùng để lưu trữ tất cả các media có trong bài posts. Newsfeed generation service: Dùng để thu thập và xếp hạng tất cả các posts phù hợp với 1 user để tạo ra newsfeed và lưu nó trong cache. Service này cũng sẽ nhận các cập nhật mới nhất và sẽ thêm các feed items mới này vào timeline của user bất kỳ. Feed notification service: Thông báo cho user các feed items mới đang có sẵn cho newsfeed của họ.  Dưới đây là biểu đồ kiến trúc ở mức high-level, User B và User C đang theo dõi User A.\n7. Detailed Component Design Ta sẽ bàn chi tiết về 2 components khác nhau.\na. Feed generation Giờ ta xét 1 ví dụ đơn giản là newsfeed generation service sẽ lấy về các posts mới nhất từ tất cả các users và entities mà Jane theo dõi; câu truy vấn sẽ giống như sau:\n(SELECT FeedItemID FROM FeedItem WHERE UserID in ( SELECT EntityOrFriendID FROM UserFollow WHERE UserID = current_user_id and type = 0(user)) ) UNION (SELECT FeedItemID FROM FeedItem WHERE EntityID in ( SELECT EntityOrFriendID FROM UserFollow WHERE UserID = current_user_id and type = 1(entity)) ) ORDER BY CreationDate DESC LIMIT 100 Các issues xảy ra với cách thiết kế này dành cho newsfeed generation service:\n Sẽ rất chậm đối với các users có nhiều bạn friends hay người theo dõi follows do ta phải thực hiện sorting/merging/ranking trên 1 lượng lớn các posts. Chúng ta tạo ra timeline khi 1 user thực hiện load trang page của họ. Điều này sẽ rất chậm và có độ trễ cao. Với những live updates, mỗi status update sẽ được cập nhật vào trong các feed updates của tất cả các followers. Điều này gây ra sự tồn đọng high backlogs trong Newsfeed Generation Service. Với những live updates, server push (hay thông báo) các posts mới tới những users có thể gây ra vấn đề nặng tải, đặc biệt là đối với những người, hay pages có lượng lớn followers. Để cải thiện hiệu năng, ta có thể tạo trước timeline và lưu nó trong 1 memory.  Offline generation for newsfeed: Chúng ta cần có các servers dành riêng cho việc liên tục tạo ra các newsfeed của users và lưu trữ chúng trong memory. Do đó bất cứ khi nào 1 user request lấy về các posts mới cho feed của họ, chúng ta có thể đơn giản lấy các feed này từ nơi lưu trữ đã tạo trước. Bằng cách sử dụng cơ chế này, thì newsfeed của user không cần phải tạo khi có yêu cầu, và do đó có thể trả về cho users bất cứ khi nào có yêu cầu.\nBất cứ khi các servers này cần tạo feed cho 1 user, chúng sẽ truy vấn để lấy về thời điểm tạo feed gần nhất được tạo với user này đầu tiên. Sau đó, các feed data mới sẽ được tạo từ thời điểm tạo này trở về sau. Chúng ta có thể lưu trữ thông tin data này trong 1 hash table, với key là UserID và value là 1 cấu trúc STRUCT giống như sau:\nStruct { LinkedHashMapFeedItemID, FeedItem feedItems; DateTime lastGenerated; } Chúng ta có thể lưu trữ FeedItemIDs trong 1 cấu trúc data structure giống như Linked HashMap hay TreeMap, chúng có thể cho phép ta không chỉ nhảy tới bất cứ feed item nào mà còn có thể lặp qua chúng thông qua map 1 cách dễ dàng. Bất cứ khi nào users muốn lấy về nhiều feed items hơn, chúng ta có thể gửi last FeedItemID mà họ đang nhìn thấy trong newsfeed của họ, và sau đó ta có thể nhảy tới FeedItemID đó trong hash-map và trả về batch/page của feed items tiếp theo từ đó.\nBao nhiêu feed items mà ta nên lưu trữ trong memory cho feed của 1 user? Thời điểm khởi đầu, chúng ta có thể quyết định lưu 500 feed items cho mỗi user, nhưng con số này có thể được điều chỉnh sau đó dựa trên mức sử dụng. Ví dụ, nếu ta giả định 1 page của 1 user feed sẽ có 20 bài posts và đa số users không bao giờ duyệt trên 10 pages feed của họ, chúng ta có thể quyết định chỉ lưu trữ 200 posts trên mỗi user. Với bất cứ user người mà muốn xem nhiều bài posts hơn (nhiều hơn những gì lưu trong memory), chúng ta có thể truy vấn chúng từ backend servers.\nChúng ta nên tạo (hay giữ trong memory) newsfeed cho tất cả users? Có rất nhiều users không đăng nhập 1 cách thường xuyên. Đây là 1 vài thứ mà ta có thể làm để xử lý điều này; 1) 1 cách tiếp cận hiển nhiên nhất là sử dụng 1 LRU cache để xóa users khỏi memory do họ không truy cập newsfeed của họ trong 1 khoảng thời gian dài. 2) 1 cách tiếp cận thông minh hơn là tìm ra kiểu đăng nhập của users để tạo ra các newsfeed của họ trước, ví dụ thời điểm nào trong ngày 1 user hoạt động và những ngày nào trong tuần mà user có thể truy cập newsfeed của họ?\nGiờ, chúng ta sẽ bàn về 1 số các giải pháp về vấn đề “live updates”.\nb. Các xuất bản Feed publishing: Tiến trình xuất bản 1 post tới tất cả những người theo dõi followers được gọi là fanount. Tương tự vậy thì giải pháp push được gọi là fanout-on-write, trong khi giải pháp pull được gọi là fanout-on-load. Chúng ta sẽ đề cập tới các lựa chọn khác nhau dùng để xuất bản feed data tới users.\n “Pull” model hay Fan-out-on-load: là phương thức liên quan tới việc giữ tất cả các feed data gần đây trong memory, do đó users có thể pull nó từ server bất cứ khi nào họ cần. Clients có thể pull feed data 1 cách thường xuyên hay thủ công bất cứ khi nào họ cần. Các vấn đề xảy ra với giải pháp này là a) Dữ liệu mới có thể không hiện thị ra cho users cho tới khi họ thực hiện 1 pull request, b) Rất khó để làm mượt mà 1 pull request, khi đại đa số pull requests sẽ trả về 1 kết quả rỗng khi không có dữ liệu mới, điều này sẽ gây lãng phí tài nguyên. “Push” model hay Fan-out-on-write: Trong 1 hệ thống push system, bất cứ khi nào 1 user xuất bản 1 bài post, ta có thể ngay lập tức push bài post này tới tất cả followers. Ưu điểm là khi tìm nạp feed, bạn không cần duyệt qua tất cả danh sách các friends và lấy feeds của mỗi người trong số họ. Điều này sẽ giảm đáng kể các read operations. Để xử lý theo cách này hiệu quả, users phải dữ 1 Long Poll request với server để nhận về các cập nhật updates. 1 vấn đề có thể phát sinh với giải pháp này là khi 1 user có hàng triệu người theo dõi followers thì server phải push updates tới rất nhiều người. Hybrid: 1 giải pháp khác là kết hợp cả 2 giải pháp trên. Ta có thể dừng push các bài posts từ những users có lượng lớn người theo dõi followers và chỉ push data với những user có lượng theo dõi hàng trăm hay hàng nghìn người. Với những users nổi tiếng, ta có thể để các người theo dõi followers pull các cập nhật updates. Do xử lý push operation thực sự là rất đắt đối với những users nổi tiếng có nhiều followers hay friends, nên việc tắt fanout cho những người này, ta có thể tiết kiệm được lượng lớn tài nguyên. 1 giải pháp khác, khi 1 user xuất bản 1 bài post, ta có thể giới hạn fanout chỉ với những người bạn đang online.  Bao nhiêu feed items mà ta có thể trả về client trong mỗi request? Chúng ta nên giới hạn max số lượng items mà 1 user có thể lấy về trong 1 request (giả sử là 20). Nhưng, ta có thể để client định nghĩa bao nhiêu phần tử feed items mà họ muốn lấy về ở mỗi request, user có thể lấy về số lượng posts khác nhau phụ thuộc vào loại thiết bị (mobile vs. desktop).\nChúng ta có phải nên luôn thông báo tới users nếu có bài post mới vừa đăng trong newsfeed của họ? Điều này khá hữu dụng đối với users khi có thể nhận được ngay thông báo khi có dữ liệu mới xuất hiện. Tuy nhiên, trên có thiết bị mobile, khi việc sử dụng data là thật sự đắt, thì điều này có thể gây ra việc tiêu tốn băng thông không cần thiết. Do đó, ít nhất là trên các thiết bị mobile, ta có thể lựa chọn không push data, và thay vào đó để user thực hiện “Pull to Refresh” để lấy về các posts mới.\n8. Feed Ranking Cách dễ dàng nhất để xếp hạng posts trong 1 newsfeed là dựa vào thời gian tạo posts, nhưng thuật toán xếp hạng ngày nay thực hiện nhiều thứ hơn để đảm bảo các posts quan trọng được xếp hạng cao hơn. ý tưởng về thuật toán sắp xếp ở mức high level đầu tiên là lựa chọn các tín hiệu để nhận biết 1 post là quan trọng và sau đó tìm ra cách để kêt hợp chúng để tính toán ra ranking score.\nĐể cụ thể hơn, chúng ta có thể lựa chọn 1 vài đặc tính phù hợp để tìm ta tính quan trọng của feed item. Ví dụ như số lượng likes, comments, shares, thời điểm update, post chứa images/videos, …và sau đó, score có thể tính toán bằng cách sử dụng các đặc tính này. Điều này nói chung là đủ cho 1 hệ thống xếp hạng đơn giản. 1 Hệ thống xếp hạng tốt hơn có thể tự cải thiện đáng kể bằng cách liên tục đánh giá xem chúng ta có đang đạt được tiến bộ về mức độ gắn bó, giữ chân người dùng, doanh thu quảng cáo, v.v.\n9. Data Partitioning a. Sharding posts và metadata:\nDo ta có lượng lớn các bài posts mới mỗi ngày và tải read thực sự rất cao, ta cần phân tán data trên nhiều server do ta cần read/write 1 cách hiệu quả. Để sharding databases dùng để lưu trữ posts và metadata của chúng, ta có thể thiết kế tương tự giống bài “Designing Twitter”.\nb. Sharding feed data:\nĐối với feed data, đang được lưu trữ trong memory, ta có thể phân tán nó dựa vào UserID. Ta có thể lưu trữ tất cả các dữ liệu của 1 user trên 1 server. Khi thực hiện lưu trữ, ta sẽ truyền UserID vào hash function để map user vào 1 cache server mà ta dùng để lưu trữ các user’s feed objects. Cũng vậy, đối với bất kỳ 1 user nào đó, do ta không kỳ vọng lưu quá 500 FeedItemIDs, do đó ta sẽ không rơi vào hoàn cảnh khi mà feed data của 1 user không chứa vừa trên 1 server. Để lấy về feed của 1 user, ta sẽ luôn luôn truy vấn trên chỉ 1 server.\n","wordCount":"3258","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"telion"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/"},"publisher":{"@type":"Organization","name":"LifeSucks","logo":{"@type":"ImageObject","url":"https://lifesucks.dev/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://lifesucks.dev/ accesskey=h title="LifeSucks (Alt + H)">LifeSucks</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://lifesucks.dev/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/series/ title=Series>
<span>Series</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://lifesucks.dev/>Home</a>&nbsp;»&nbsp;<a href=https://lifesucks.dev/posts/>Posts</a></div>
<h1 class=post-title>
Bài 13: Cách thiết kế Facebook Newsfeed
</h1>
<div class=post-description>
Chúng ta sẽ cùng nhau thiết kế Facebook Newsfeed
</div>
<div class=post-meta>16 min&nbsp;·&nbsp;telion&nbsp;|&nbsp;<a href=https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/grokking-system-design-interviews/Designing%20Facebook%e2%80%99s%20Newsfeed.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#1-facebook-newsfeed-l%c3%a0-g%c3%ac aria-label="1. Facebook newsfeed là gì?">1. Facebook newsfeed là gì?</a></li>
<li>
<a href=#2-y%c3%aau-c%e1%ba%a7u-requirements-v%c3%a0-m%e1%bb%a5c-ti%c3%aau-goals-c%e1%bb%a7a-h%e1%bb%87-th%e1%bb%91ng aria-label="2. Yêu cầu Requirements và mục tiêu Goals của hệ thống">2. Yêu cầu Requirements và mục tiêu Goals của hệ thống</a></li>
<li>
<a href=#3-%c6%b0%e1%bb%9bc-l%c6%b0%e1%bb%a3ng-tr%e1%bb%af-l%c6%b0%e1%bb%a3ng-v%c3%a0-c%c3%a1c-r%c3%a0ng-bu%e1%bb%99c aria-label="3. Ước lượng trữ lượng và các ràng buộc">3. Ước lượng trữ lượng và các ràng buộc</a></li>
<li>
<a href=#4-system-apis aria-label="4. System APIs">4. System APIs</a></li>
<li>
<a href=#5-database-design aria-label="5. Database Design">5. Database Design</a></li>
<li>
<a href=#6-high-level-system-design aria-label="6. High Level System Design">6. High Level System Design</a></li>
<li>
<a href=#7-detailed-component-design aria-label="7. Detailed Component Design">7. Detailed Component Design</a></li>
<li>
<a href=#8-feed-ranking aria-label="8. Feed Ranking">8. Feed Ranking</a></li>
<li>
<a href=#9-data-partitioning aria-label="9. Data Partitioning">9. Data Partitioning</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=1-facebook-newsfeed-là-gì>1. Facebook newsfeed là gì?<a hidden class=anchor aria-hidden=true href=#1-facebook-newsfeed-là-gì>#</a></h2>
<p>1 Newsfeed là 1 danh sách các bài stories được cập nhật liên tục nằm chính giữa trang Facebook’s homepage. Nó bao gồm các cập nhật liên quan tới trạng thái status, photos, videos, links, app activity hay các likes từ những người, trang pages, hay groups mà người dùng user theo dõi follow trên Facebook.</p>
<p>Với bất cứ hệ thống mạng xã hội nào mà bạn thiết kế như Twitter, Instagram, hay Facebook thì bạn sẽ cần 1 hệ thống kiểu Newsfeed để hiện thị các thông tin cập nhật từ những người bạn và những người mà bạn theo dõi.</p>
<h2 id=2-yêu-cầu-requirements-và-mục-tiêu-goals-của-hệ-thống>2. Yêu cầu Requirements và mục tiêu Goals của hệ thống<a hidden class=anchor aria-hidden=true href=#2-yêu-cầu-requirements-và-mục-tiêu-goals-của-hệ-thống>#</a></h2>
<p>Chúng ta sẽ thiết kế 1 hệ thống newsfeed cho Facebook theo các yêu cầu sau:</p>
<p><strong>Yêu cầu về mặt tính năng:</strong></p>
<ol>
<li>Newsfeed cần được tạo ra dựa trên các bài posts từ những người, trang pages, groups mà người dùng user theo dõi follow.</li>
<li>1 người dùng user có thể có rất nhiều bạn và theo dõi follow 1 lượng lớn các pages/groups.</li>
<li>Feeds có thể chứ images, videos, hay chỉ chứa text.</li>
<li>Hệ thống của chúng ta cần hỗ trợ thêm mới các bài posts mới nhanh nhất có thể khi chúng vừa mới xuất hiện cho tất cả các users đang hoạt động.</li>
</ol>
<p><strong>Yêu cầu không liên quan tới tính năng:</strong></p>
<ol>
<li>Hệ thống có khả năng tạo ra newsfeed cho bất cứ user nào 1 cách real-time và độ trễ tối đa là 2s.</li>
<li>1 bài post không cần tới 5s để nó xuất hiện trong feed của 1 user giả định là bài post vừa được đăng.</li>
</ol>
<h2 id=3-ước-lượng-trữ-lượng-và-các-ràng-buộc>3. Ước lượng trữ lượng và các ràng buộc<a hidden class=anchor aria-hidden=true href=#3-ước-lượng-trữ-lượng-và-các-ràng-buộc>#</a></h2>
<p>Ta giả định 1 user trung bình sẽ có 300 bạn và theo dõi 200 pages.</p>
<p><strong>Ước lượng về traffic:</strong> Giả sử ta có 300M người dùng hoạt động hàng ngày và trung bình mỗi người dùng sẽ làm mới timeline của họ 5 lần 1 ngày. Kết quả là sẽ có 1.5B newsfeed request 1 ngày và xấp xỉ 17,500 request mỗi giây.</p>
<p><strong>Ước lượng về storage:</strong> Ở mức trung bình, ta giả định chúng ta có khoảng 500 posts trên mọi newsfeed của mỗi user và chúng ta sẽ giữ chúng trong bộ nhớ memory để lấy chúng ra 1 cách nhanh nhất. Chúng ta cũng giả định rằng trung bình mỗi bài post có kích thước khoảng 1KB. Điều này có nghĩa rằng chúng ta cần lưu trữ khoảng 500KB dữ liệu data trên mỗi user. Để lưu trữ được tất cả data cho tất cả các users đang active chúng ta cần 150TB memory. Nếu 1 server có thể đáp ứng được 100GB thì chúng ta cần khoảng 1500 servers để giữ được 500 bài posts mới nhất trong memory cho tất cả các users đang active.</p>
<h2 id=4-system-apis>4. System APIs<a hidden class=anchor aria-hidden=true href=#4-system-apis>#</a></h2>
<blockquote>
<p>Khi ta đã chốt được các yêu cầu requirements, thì ý tưởng tốt là định nghĩa các system APIs. Điều này sẽ phản ánh đúng những gì mà hệ thống kì vọng.</p>
</blockquote>
<p>Chúng ta cần có SOAP hay REST APIs để expose ra các tính năng của các service. Đoạn ví dụ dưới dùng để định nghĩa API dùng để lấy ra newsfeed:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>getUserFeed<span style=color:#f92672>(</span>api_dev_key, user_id, since_id, count, max_id, exclude_replies<span style=color:#f92672>)</span>
</code></pre></div><p><strong>Các tham số:</strong></p>
<ul>
<li><strong>api_dev_key (string):</strong> Api developer key cần phải được đăng ký để sử dụng và dùng để throttle users dựa trên hạn mức quota mà họ được cấp.</li>
<li><strong>user_id (number):</strong> ID của user mà hệ thống dùng để tạo newsfeed.</li>
<li><strong>since_id (number):</strong> Không bắt buộc, trả về kết quả với 1 ID cao hơn (mới hơn) ID cho trước.</li>
<li><strong>count (number):</strong> Không bắt buộc, định nghĩa số lượng các feed items cần lấy ra, giới hạn max là 200.</li>
<li><strong>max_id (number):</strong> Không bắt buộc, trả về kết quả với 1 ID nhỏ hơn hoặc bằng (cũ hơn) ID cho trước.</li>
<li><strong>exclude_replies(boolean):</strong> Không bắt buộc, Tham số này sẽ ngăn chặn việc trả về các replies xuất hiện trong kết quả timeline được trả về.</li>
</ul>
<p><strong>Kết quả trả về:</strong> (JSON) trả về 1 JSON object chứa 1 danh sách các feed items.</p>
<h2 id=5-database-design>5. Database Design<a hidden class=anchor aria-hidden=true href=#5-database-design>#</a></h2>
<p>Ta sẽ có 3 đối tượng objects chính: User, Entity (e.g. page, group, etc.), and FeedItem (or Post). Dưới đây là 1 vài quan sát về quan hệ relationships giữa các đối tượng này:</p>
<ul>
<li>1 user có thể follow các đối tượng entities khác và có thể là bạn với users khác.</li>
<li>Cả users và các đối tượng entities có thể post FeedItems chứa text, images hay videos.</li>
<li>Mỗi FeedItem sẽ có 1 UserID dùng để xác định User tạo ra nó. Cho đơn giản, ta giả định chỉ có users mới tạo được feed items mặc dù Facebook Pages cũng có thể tạo ra.</li>
<li>Mỗi FeedItem có thể có 1 EntityID dùng để trỏ tới trang page hay group mà bài posts được tạo ra.</li>
</ul>
<p>Nếu ta đang sử dụng 1 relational database, chúng ta sẽ cần mô hình hóa 2 mối quan hệ relations: User-Entity relation và FeedItem-Media relation. Do mỗi user có thể là bạn với nhiều người khác và theo dõi follow rất nhiều đối tượng entities, ta có thể lưu trữ mối quan hệ relation ra thành bảng table riêng. cột &ldquo;Type&rdquo; trong bảng &ldquo;UserFollow&rdquo; dùng để xác định đối tượng entity đang được follow là 1 User hay Entity. Tương tự ta cũng cần có 1 bảng table cho FeedMedia relation.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/4506227120275456.svg alt="Database Design" title="Database Design">
</p>
<h2 id=6-high-level-system-design>6. High Level System Design<a hidden class=anchor aria-hidden=true href=#6-high-level-system-design>#</a></h2>
<p>Ở mức high level, vấn đề của chúng ta chia làm 2 phần:</p>
<p><strong>Feed generation:</strong> Newsfeed được tạo từ các bài posts (hay feed items) từ những users hay entities (pages hay groups) mà 1 user theo dõi. Do đó, bất cứ khi nào hệ thống nhận được yêu cầu tạo feed cho 1 user (ví dụ là Jane), thì chúng ta sẽ thực hiện các bước sau:</p>
<ol>
<li>Lấy về IDs của tất cả các users và entities mà Jane theo dõi.</li>
<li>Lấy về các bài posts mới nhất, phổ biến nhất, phù hợp nhất cho những IDs này. Đây là posts tiềm năng mà ta có thể hiện thị chúng trong newsfeed của Jane.</li>
<li>Đánh giá các bài posts này dựa trên sự phù hợp với Jane. Điều này phản ánh trực tiếp với feed của Jane hiện tại.</li>
<li>Lưu trữ feed này vào trong cache và trả về top các bài posts (tầm 20) để hiện thị trong Jane feed.</li>
<li>Ở phía front-end, khi Jane chạm tới cuối feed hiện tại của cô ấy, thì cô ấy có thể lấy về tiếp 20 posts tiếp theo từ server và cứ tiếp tục như vậy.</li>
</ol>
<p><strong>Feed publishing:</strong> Bất cứ khi nào Jane load trang newsfeed page của cô ấy, cô ấy phải thực hiện request và pull các feed items từ server. Bất cứ khi nào cô ấy chạm vào đáy của feed hiện tại, thì cô ấy có thể pull data mới từ server. Với những phần tử items mới hơn thì server có thể thông báo cho Jane và cô ấy có thể pull hay server có thể push những posts mới này xuống. Chúng ta sẽ bàn về các lựa chọn này sau.</p>
<p>Ở mức high level, chúng ta chỉ cần các components sau trong Newsfeed service:</p>
<ol>
<li><strong>Web servers:</strong> Cần duy trì 1 connection với user. Connection này có thể được sử dụng để chuyển dữ liệu data giữa user và server.</li>
<li><strong>Application server:</strong> Thực hiện xử lý các luồng nghiệp vụ workflows dùng để lưu trữ các posts mới trong database servers. Chúng ta sẽ cần 1 vài application servers để lấy về và để push newsfeed xuống end user.</li>
<li><strong>Metadata database and cache:</strong> Dùng để lưu trữ các thông tin metadata liên quan tới Users, Pages, Groups.</li>
<li><strong>Posts database and cache:</strong> Dùng để lưu trữ các thông tin metadata liên quan tới posts và các nội dung contents của họ.</li>
<li><strong>Video and photo storage, and cache:</strong> Dạng blob storage, dùng để lưu trữ tất cả các media có trong bài posts.</li>
<li><strong>Newsfeed generation service:</strong> Dùng để thu thập và xếp hạng tất cả các posts phù hợp với 1 user để tạo ra newsfeed và lưu nó trong cache. Service này cũng sẽ nhận các cập nhật mới nhất và sẽ thêm các feed items mới này vào timeline của user bất kỳ.</li>
<li><strong>Feed notification service:</strong> Thông báo cho user các feed items mới đang có sẵn cho newsfeed của họ.</li>
</ol>
<p>Dưới đây là biểu đồ kiến trúc ở mức high-level, User B và User C đang theo dõi User A.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/6485520234840064.svg alt="Facebook Newsfeed Architecture" title="Facebook Newsfeed Architecture">
</p>
<h2 id=7-detailed-component-design>7. Detailed Component Design<a hidden class=anchor aria-hidden=true href=#7-detailed-component-design>#</a></h2>
<p>Ta sẽ bàn chi tiết về 2 components khác nhau.</p>
<p><strong>a. Feed generation</strong>
Giờ ta xét 1 ví dụ đơn giản là newsfeed generation service sẽ lấy về các posts mới nhất từ tất cả các users và entities mà Jane theo dõi; câu truy vấn sẽ giống như sau:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>(<span style=color:#66d9ef>SELECT</span> FeedItemID <span style=color:#66d9ef>FROM</span> FeedItem <span style=color:#66d9ef>WHERE</span> UserID <span style=color:#66d9ef>in</span> (
    <span style=color:#66d9ef>SELECT</span> EntityOrFriendID <span style=color:#66d9ef>FROM</span> UserFollow <span style=color:#66d9ef>WHERE</span> UserID <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>current_user_id<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>type</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>user</span>))
)
<span style=color:#66d9ef>UNION</span>
(<span style=color:#66d9ef>SELECT</span> FeedItemID <span style=color:#66d9ef>FROM</span> FeedItem <span style=color:#66d9ef>WHERE</span> EntityID <span style=color:#66d9ef>in</span> (
    <span style=color:#66d9ef>SELECT</span> EntityOrFriendID <span style=color:#66d9ef>FROM</span> UserFollow <span style=color:#66d9ef>WHERE</span> UserID <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>current_user_id<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>type</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>(entity))
)
<span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> CreationDate <span style=color:#66d9ef>DESC</span> 
<span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>100</span>
</code></pre></div><p>Các issues xảy ra với cách thiết kế này dành cho newsfeed generation service:</p>
<ol>
<li>Sẽ rất chậm đối với các users có nhiều bạn friends hay người theo dõi follows do ta phải thực hiện sorting/merging/ranking trên 1 lượng lớn các posts.</li>
<li>Chúng ta tạo ra timeline khi 1 user thực hiện load trang page của họ. Điều này sẽ rất chậm và có độ trễ cao.</li>
<li>Với những live updates, mỗi status update sẽ được cập nhật vào trong các feed updates của tất cả các followers. Điều này gây ra sự tồn đọng high backlogs trong Newsfeed Generation Service.</li>
<li>Với những live updates, server push (hay thông báo) các posts mới tới những users có thể gây ra vấn đề nặng tải, đặc biệt là đối với những người, hay pages có lượng lớn followers. Để cải thiện hiệu năng, ta có thể tạo trước timeline và lưu nó trong 1 memory.</li>
</ol>
<p><strong>Offline generation for newsfeed:</strong> Chúng ta cần có các servers dành riêng cho việc liên tục tạo ra các newsfeed của users và lưu trữ chúng trong memory. Do đó bất cứ khi nào 1 user request lấy về các posts mới cho feed của họ, chúng ta có thể đơn giản lấy các feed này từ nơi lưu trữ đã tạo trước. Bằng cách sử dụng cơ chế này, thì newsfeed của user không cần phải tạo khi có yêu cầu, và do đó có thể trả về cho users bất cứ khi nào có yêu cầu.</p>
<p>Bất cứ khi các servers này cần tạo feed cho 1 user, chúng sẽ truy vấn để lấy về thời điểm tạo feed gần nhất được tạo với user này đầu tiên. Sau đó, các feed data mới sẽ được tạo từ thời điểm tạo này trở về sau. Chúng ta có thể lưu trữ thông tin data này trong 1 hash table, với key là UserID và value là 1 cấu trúc STRUCT giống như sau:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Struct <span style=color:#f92672>{</span>
    LinkedHashMap<span style=color:#f92672>&lt;</span>FeedItemID<span style=color:#f92672>,</span> FeedItem<span style=color:#f92672>&gt;</span> feedItems<span style=color:#f92672>;</span>
    DateTime lastGenerated<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Chúng ta có thể lưu trữ FeedItemIDs trong 1 cấu trúc data structure giống như Linked HashMap hay TreeMap, chúng có thể cho phép ta không chỉ nhảy tới bất cứ feed item nào mà còn có thể lặp qua chúng thông qua map 1 cách dễ dàng. Bất cứ khi nào users muốn lấy về nhiều feed items hơn, chúng ta có thể gửi last FeedItemID mà họ đang nhìn thấy trong newsfeed của họ, và sau đó ta có thể nhảy tới FeedItemID đó trong hash-map và trả về batch/page của feed items tiếp theo từ đó.</p>
<p><strong>Bao nhiêu feed items mà ta nên lưu trữ trong memory cho feed của 1 user?</strong> Thời điểm khởi đầu, chúng ta có thể quyết định lưu 500 feed items cho mỗi user, nhưng con số này có thể được điều chỉnh sau đó dựa trên mức sử dụng. Ví dụ, nếu ta giả định 1 page của 1 user feed sẽ có 20 bài posts và đa số users không bao giờ duyệt trên 10 pages feed của họ, chúng ta có thể quyết định chỉ lưu trữ 200 posts trên mỗi user. Với bất cứ user người mà muốn xem nhiều bài posts hơn (nhiều hơn những gì lưu trong memory), chúng ta có thể truy vấn chúng từ backend servers.</p>
<p><strong>Chúng ta nên tạo (hay giữ trong memory) newsfeed cho tất cả users?</strong> Có rất nhiều users không đăng nhập 1 cách thường xuyên. Đây là 1 vài thứ mà ta có thể làm để xử lý điều này; 1) 1 cách tiếp cận hiển nhiên nhất là sử dụng 1 LRU cache để xóa users khỏi memory do họ không truy cập newsfeed của họ trong 1 khoảng thời gian dài. 2) 1 cách tiếp cận thông minh hơn là tìm ra kiểu đăng nhập của users để tạo ra các newsfeed của họ trước, ví dụ thời điểm nào trong ngày 1 user hoạt động và những ngày nào trong tuần mà user có thể truy cập newsfeed của họ?</p>
<p>Giờ, chúng ta sẽ bàn về 1 số các giải pháp về vấn đề “live updates”.</p>
<p><strong>b. Các xuất bản Feed publishing:</strong>
Tiến trình xuất bản 1 post tới tất cả những người theo dõi followers được gọi là fanount. Tương tự vậy thì giải pháp push được gọi là fanout-on-write, trong khi giải pháp pull được gọi là fanout-on-load. Chúng ta sẽ đề cập tới các lựa chọn khác nhau dùng để xuất bản feed data tới users.</p>
<ol>
<li>&ldquo;Pull&rdquo; model hay Fan-out-on-load: là phương thức liên quan tới việc giữ tất cả các feed data gần đây trong memory, do đó users có thể pull nó từ server bất cứ khi nào họ cần. Clients có thể pull feed data 1 cách thường xuyên hay thủ công bất cứ khi nào họ cần. Các vấn đề xảy ra với giải pháp này là a) Dữ liệu mới có thể không hiện thị ra cho users cho tới khi họ thực hiện 1 pull request, b) Rất khó để làm mượt mà 1 pull request, khi đại đa số pull requests sẽ trả về 1 kết quả rỗng khi không có dữ liệu mới, điều này sẽ gây lãng phí tài nguyên.</li>
<li>&ldquo;Push&rdquo; model hay Fan-out-on-write: Trong 1 hệ thống push system, bất cứ khi nào 1 user xuất bản 1 bài post, ta có thể ngay lập tức push bài post này tới tất cả followers. Ưu điểm là khi tìm nạp feed, bạn không cần duyệt qua tất cả danh sách các friends và lấy feeds của mỗi người trong số họ. Điều này sẽ giảm đáng kể các read operations. Để xử lý theo cách này hiệu quả, users phải dữ 1 Long Poll request với server để nhận về các cập nhật updates. 1 vấn đề có thể phát sinh với giải pháp này là khi 1 user có hàng triệu người theo dõi followers thì server phải push updates tới rất nhiều người.</li>
<li>Hybrid: 1 giải pháp khác là kết hợp cả 2 giải pháp trên. Ta có thể dừng push các bài posts từ những users có lượng lớn người theo dõi followers và chỉ push data với những user có lượng theo dõi hàng trăm hay hàng nghìn người. Với những users nổi tiếng, ta có thể để các người theo dõi followers pull các cập nhật updates. Do xử lý push operation thực sự là rất đắt đối với những users nổi tiếng có nhiều followers hay friends, nên việc tắt fanout cho những người này, ta có thể tiết kiệm được lượng lớn tài nguyên. 1 giải pháp khác, khi 1 user xuất bản 1 bài post, ta có thể giới hạn fanout chỉ với những người bạn đang online.</li>
</ol>
<p><strong>Bao nhiêu feed items mà ta có thể trả về client trong mỗi request?</strong> Chúng ta nên giới hạn max số lượng items mà 1 user có thể lấy về trong 1 request (giả sử là 20). Nhưng, ta có thể để client định nghĩa bao nhiêu phần tử feed items mà họ muốn lấy về ở mỗi request, user có thể lấy về số lượng posts khác nhau phụ thuộc vào loại thiết bị (mobile vs. desktop).</p>
<p><strong>Chúng ta có phải nên luôn thông báo tới users nếu có bài post mới vừa đăng trong newsfeed của họ?</strong> Điều này khá hữu dụng đối với users khi có thể nhận được ngay thông báo khi có dữ liệu mới xuất hiện. Tuy nhiên, trên có thiết bị mobile, khi việc sử dụng data là thật sự đắt, thì điều này có thể gây ra việc tiêu tốn băng thông không cần thiết. Do đó, ít nhất là trên các thiết bị mobile, ta có thể lựa chọn không push data, và thay vào đó để user thực hiện “Pull to Refresh” để lấy về các posts mới.</p>
<h2 id=8-feed-ranking>8. Feed Ranking<a hidden class=anchor aria-hidden=true href=#8-feed-ranking>#</a></h2>
<p>Cách dễ dàng nhất để xếp hạng posts trong 1 newsfeed là dựa vào thời gian tạo posts, nhưng thuật toán xếp hạng ngày nay thực hiện nhiều thứ hơn để đảm bảo các posts quan trọng được xếp hạng cao hơn. ý tưởng về thuật toán sắp xếp ở mức high level đầu tiên là lựa chọn các tín hiệu để nhận biết 1 post là quan trọng và sau đó tìm ra cách để kêt hợp chúng để tính toán ra ranking score.</p>
<p>Để cụ thể hơn, chúng ta có thể lựa chọn 1 vài đặc tính phù hợp để tìm ta tính quan trọng của feed item. Ví dụ như số lượng likes, comments, shares, thời điểm update, post chứa images/videos, &mldr;và sau đó, score có thể tính toán bằng cách sử dụng các đặc tính này. Điều này nói chung là đủ cho 1 hệ thống xếp hạng đơn giản. 1 Hệ thống xếp hạng tốt hơn có thể tự cải thiện đáng kể bằng cách liên tục đánh giá xem chúng ta có đang đạt được tiến bộ về mức độ gắn bó, giữ chân người dùng, doanh thu quảng cáo, v.v.</p>
<h2 id=9-data-partitioning>9. Data Partitioning<a hidden class=anchor aria-hidden=true href=#9-data-partitioning>#</a></h2>
<p><strong>a. Sharding posts và metadata:</strong></p>
<p>Do ta có lượng lớn các bài posts mới mỗi ngày và tải read thực sự rất cao, ta cần phân tán data trên nhiều server do ta cần read/write 1 cách hiệu quả. Để sharding databases dùng để lưu trữ posts và metadata của chúng, ta có thể thiết kế tương tự giống bài &ldquo;Designing Twitter&rdquo;.</p>
<p><strong>b. Sharding feed data:</strong></p>
<p>Đối với feed data, đang được lưu trữ trong memory, ta có thể phân tán nó dựa vào UserID. Ta có thể lưu trữ tất cả các dữ liệu của 1 user trên 1 server. Khi thực hiện lưu trữ, ta sẽ truyền UserID vào hash function để map user vào 1 cache server mà ta dùng để lưu trữ các user’s feed objects. Cũng vậy, đối với bất kỳ 1 user nào đó, do ta không kỳ vọng lưu quá 500 FeedItemIDs, do đó ta sẽ không rơi vào hoàn cảnh khi mà feed data của 1 user không chứa vừa trên 1 server. Để lấy về feed của 1 user, ta sẽ luôn luôn truy vấn trên chỉ 1 server.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://lifesucks.dev/tags/system-design-interviews/>system design interviews</a></li>
<li><a href=https://lifesucks.dev/tags/designing-facebooks-newsfeed/>Designing Facebook’s Newsfeed</a></li>
<li><a href=https://lifesucks.dev/tags/designing-twitter-newsfeed/>Designing Twitter Newsfeed</a></li>
<li><a href=https://lifesucks.dev/tags/designing-instagram-newsfeed/>Designing Instagram Newsfeed</a></li>
<li><a href=https://lifesucks.dev/tags/designing-quora-newsfeed/>Designing Quora Newsfeed</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://lifesucks.dev/posts/emoji-support/>
<span class=title>« Prev Page</span>
<br>
<span>Emoji Support</span>
</a>
<a class=next href=https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/>
<span class=title>Next Page »</span>
<br>
<span>Bài 1: Các bước để trả lời được phỏng vấn System Design Interviews</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on twitter" href="https://twitter.com/intent/tweet/?text=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f&hashtags=systemdesigninterviews%2cDesigningFacebook%e2%80%99sNewsfeed%2cDesigningTwitterNewsfeed%2cDesigningInstagramNewsfeed%2cDesigningQuoraNewsfeed"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f&title=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed&summary=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed&source=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f&title=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on whatsapp" href="https://api.whatsapp.com/send?text=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed%20-%20https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 13: Cách thiết kế  Facebook Newsfeed on telegram" href="https://telegram.me/share/url?text=B%c3%a0i%2013%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%20%20Facebook%20Newsfeed&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-facebooks-newsfeed%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://lifesucks.dev/>LifeSucks</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>