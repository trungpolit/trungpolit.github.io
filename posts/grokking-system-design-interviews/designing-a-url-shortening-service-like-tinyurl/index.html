<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL | LifeSucks</title>
<meta name=keywords content="system design interviews,Design URL Shortening service,Design TinyURL">
<meta name=description content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ URL Shortening service giống như TinyURL. Dịch vụ này sẽ cung cấp các định danh ngắn gọn dùng để điều hướng tới các URLs dài">
<meta name=author content="telion">
<link rel=canonical href=https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lifesucks.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://lifesucks.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://lifesucks.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://lifesucks.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://lifesucks.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet type=text/css href=https://lifesucks.dev/css/custom.css>
<meta property="og:title" content="Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL">
<meta property="og:description" content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ URL Shortening service giống như TinyURL. Dịch vụ này sẽ cung cấp các định danh ngắn gọn dùng để điều hướng tới các URLs dài">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/"><meta property="og:image" content="https://lifesucks.dev/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/"><meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/"><meta property="og:see_also" content="https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://lifesucks.dev/papermod-cover.png">
<meta name=twitter:title content="Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL">
<meta name=twitter:description content="Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ URL Shortening service giống như TinyURL. Dịch vụ này sẽ cung cấp các định danh ngắn gọn dùng để điều hướng tới các URLs dài">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lifesucks.dev/posts/"},{"@type":"ListItem","position":2,"name":"Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL","item":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL","name":"Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL","description":"Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ URL Shortening service giống như TinyURL. Dịch vụ này sẽ cung cấp các định danh ngắn gọn dùng để điều hướng tới các URLs dài","keywords":["system design interviews","Design URL Shortening service","Design TinyURL"],"articleBody":"1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening? URL shortening được sử dụng để tạo ra các định danh ngắn gọn hơn shorter aliases cho các URLs dài dòng. Chúng ta gọi các định danh được làm ngắn này là các “short links.”. Các users được điều hướng tới URL gốc khi họ thực hiện truy cập vào các short links này. Các short links sẽ tiết kiệm nhiều không gian khi hiện thị, in ấn, truyền thông điệp hay tweeted. Thêm nữa, các users thường hiếm khi gõ sai khi thực hiện gõ các URLs được làm ngắn gọn lại.\nVí dụ, nếu chúng ta làm ngắn URL sau thông qua TinyURL:\nhttps://www.educative.io/courses/grokking-the-system-design-interview/m2ygV4E81AR Chúng ta sẽ nhận được kết quả:\nhttps://tinyurl.com/rxcsyr3r URL được làm ngắn chỉ bằng 1 phần 3 so với URL gốc. Hệ thống URL shortening được sử dụng để tối ưu links thông qua nhiều thiết bị devices, có thể track được các links cụ thể để phân tích audience, đo lường hiệu quả của chiến dịch quảng cáo, hay dùng để ẩn đi URLs gốc.\nNếu bạn chưa từng sử dụng tinyurl.com trước đây, bạn nên thử tạo ra 1 shortened URL và bỏ thời gian để sử dụng 1 số options khác nhau do dịch vụ cung cấp. Nó sẽ giúp bạn hiểu về chương này.\n2. Yêu cầu và mục tiêu của hệ thống  Bạn phải luôn luôn làm rõ các yêu cầu ngay từ thời điểm bắt đầu của buổi phỏng vấn. Và đảm bảo chắc chắn rằng đặt ra các câu hỏi để tìm ra chính xác phạm vi scope của hệ thống.\n Hệ thống URL shortening system sẽ có các yêu cầu như sau: Các yêu cầu về mặt tính năng:\n Đưa ra 1 URL, dịch vụ của chúng ta sẽ tạo ra 1 định danh ngắn hơn và duy nhất cho nó. Định danh này được gọi là 1 short link. Link này được làm ngắn gọn đủ để dễ dàng khi thực hiện copied và pasted vào trong các ứng dụng applications. Khi users truy cập 1 short link, dịch vụ của chúng ta sẽ điều hướng họ tới link gốc. Các users có thể tùy chọn cấu hình tùy chỉnh custom short link cho URL của họ. Các links sẽ bị hết hạn sau 1 khoảng thời gian. Các users có thể định nghĩa được thời gian hết hạn này.  Các yêu cầu không liên quan tới tính năng:\n Hệ thống phải có tính sẵn sàng cao. Đây là yêu cầu bắt buộc bởi vì khi hệ thống bị down, thì tất cả các chuyển hướng URL sẽ gặp lỗi. Chuyển hướng URL nên xảy ra theo thời gian thực với độ trễ thấp. Các Shortened links nên được tạo ra 1 cách bất định (khó đoán trước).  Các yêu cầu mở rộng:\n Phân tích Analytics, ví dụ 1 url được chuyển hướng bao nhiêu lần? Dịch vụ nên được truy cập được thông qua REST APIs bởi các services khác.  3. Định lượng sức chứa và các ràng buộc Hệ thống của ta sẽ nặng về read. Sẽ có rất nhiều chuyển hướng redirection requests so với các new URL shortenings. Ta giải định tỉ lệ này khoảng 100:1 giữa read và write.\nĐịnh lượng traffic: Giả sử, chúng ta sẽ có 500M new URL shortenings mới mỗi tháng, với tỉ lệ 100:1 read/write, ta kì vọng có 50B (50 tỷ) chuyển hướng redirections với cùng chu kỳ:\n100*500M = 50B Số lượng truy vấn trên giây Queries Per Second (QPS) là bao nhiêu? New URLs shortenings được làm ngắn trên mỗi giây:\n500 million / (30 days * 24 hours * 3600 seconds) = ~200 URLs/s Xét tới tỉ lệ 100:1 read/write, URLs redirections trên mỗi giây sẽ là:\n100 * 200 URLs/s = 20K/s Định lượng lưu trữ storage: Giả sử ta lưu trữ mọi URL shortening request (bao gồm cả shortened link tương ứng với nó) trong vòng 5 năm. Do ta kỳ vọng có 500M new URLs mỗi tháng, thì tổng số objects mà ta kỳ vọng lưu trữ là 30B (30 tỷ):\n500 million * 5 years * 12 months = 30 billion Ta giả định mỗi object được lưu trữ mất xấp xỉ 500 bytes. Ta sẽ cần 15TB lưu trữ storage:\n30 billion * 500 bytes = 15 TB Định lượng băng thông Bandwidth: Với các write requests, do chúng ta kỳ vọng 200 new URLs trên mỗi giây, tổng số dữ liệu incoming data sẽ khoảng 100KB trên giây:\n200 * 500 bytes = 100 KB/s Với các read requests, do mỗi giây ra kỳ vọng ~ 20K chuyển hướng URLs redirections, tổng số dữ liệu outgoing data sẽ khoảng 10MB trên giây:\n20K * 500 bytes = ~10 MB/s Định lượng memory: Nếu ta muốn cache 1 vài hot URLs mà thường xuyên được truy cập, số lượng memory và ta cần để lưu trữ chúng là bao nhiêu? Nếu ta tuân theo định luật 80-20 rule, có nghĩa là 20% số URLs sẽ tạo ra 80% traffic, Chúng ta sẽ muốn cache lại 20% hot URLs. Do ta có khoảng 20K requests trên giây, ta sẽ có khoảng 1.7B (tỷ) requests mỗi ngày:\n20K * 3600 seconds * 24 hours = ~1.7 billion Ta sẽ cache lại 20% số requests này, ta sẽ cần 170GB memory:\n0.2 * 1.7 billion * 500 bytes = ~170GB 1 điểm nữa ta cần lưu ý ở đây là sẽ có nhiều duplicate requests tới cùng 1 URL, nên số lượng memory mà ta sử dụng sẽ thấp hơn 170GB. Định lượng ở mức High-level: Giả định có 500M new URLs mỗi tháng và tỷ lệ 100:1 read:write, bảng sau đây sẽ chỉ ra định lượng tổng quan của service:\n   Chỉ số Định lượng     New URLS 200/s   URL redirections 20k/s   Incoming data 100KB/s   Outgoing data 10MB/s   Storage for 5 years 15TB   Memory for cache 170GB    4. System APIs  Khi chúng ta đã hoàn thành việc làm rõ yêu cầu, sẽ luôn là 1 ý tưởng tốt để định nghĩa ra các system APIs. Do đây đúng là những gì mà hệ thống kỳ vọng\n Chúng ta có thể tạo ra SOAP hay REST APIs để lộ ra các tính năng của hệ thống. Đoạn mã dưới đây định nghĩa APIs dùng để tạo mới và xóa URLs:\ncreateURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None) Các tham số:\n api_dev_key (string): API developer key của 1 account đã đăng ký. Nó sẽ được sử dụng cho nhiều mục đích khác như việc giới hạn gọi api của users dựa trên quota được cấp. original_url (string): URL gốc được làm ngắn custom_alias (string): custom key tùy chọn cho URL. user_name (string): tùy chọn user name được dùng để mã hóa encoding. expire_date (string): tùy chọn ngày hết hạn cho shortened URL.  Return:(string) Khi việc thêm mới thành công nó sẽ trả về shortened URL; mặt khác nó sẽ trả về 1 mã lỗi error code.\ndeleteURL(api_dev_key, url_key) Với url_key là chuỗi biểu thị shortened URL được trả về; Nếu xóa thành công sẽ trả về “URL Removed”. Cách mà ta phát hiện và ngăn chặn việc lạm quyền? Để ngăn chặn điều này, ta có thể giới hạn users thông qua api_dev_key. Mỗi api_dev_key có thể bị giới hạn 1 số lượng tạo URL creations hay chuyển hướng redirections trên 1 khoảng thời gian (Điều này có thể được thiết lập các khoảng thời gian khác nhau trên mỗi developer key).\n5. Database Design  Định nghĩa DB schema trong những bước đầu tiên của buổi phỏng vấn sẽ giúp hiểu được về luồng data flow giữa các thành phần components khác nhau trong hệ thống và từ đó nó sẽ hướng chúng ta tới việc quy hoạch phân vùng dữ liệu.\n Có 1 vài quan sát về bản chất dữ liệu mà chúng ta sẽ lưu trữ như sau:\n Chúng ta cần lưu trữ hàng tỷ bản ghi. Mỗi object chúng ta lưu trữ thường rất nhỏ (nhỏ hơn 1K). Không có mối quan hệ relationships giữa các bản ghi records–hơn là việc cần lưu lại user nào tạo ra URL. Service thiên về read.  Database schema Chúng ta cần có 2 bảng tables: 1 dùng để lưu trữ thông tin về URL mapping và 1 bảng lưu trữ về thông tin user data người đã tạo ra short link.\nLoại database nào mà ta nên sử dụng? Do ta ước tính cần lưu trữ hàng tỷ bản ghi và ta không cần sử dụng mối quan hệ relationships giữa các objects - 1 NoSQL giống như DynamoDB, Cassandra hay Riak là lựa chọn phù hợp. Lựa chọn theo hướng NoSQL sẽ giúp dễ dàng mở rộng scale hơn.\n6. Basic System Design và Algorithm Vấn đề mà ta muốn giải quyết tại đây là cách tạo ra 1 định danh ngắn gọn và duy nhất cho 1 URL nào đó. Trong ví dụ về TinyURL ở phần 1, shortened URL có giá trị là “https://tinyurl.com/rxcsyr3r\". 8 kí tự cuối trong chuỗi URL này chính là định danh mà ta muốn tạo. Ta sẽ đưa ra 2 giải pháp tại đây:\na. Mã hóa URL gốc Ta có thể tạo ra 1 chuỗi unique hash (MD5 hay SHA256) từ 1 URL đã cho. Chuỗi hash có thể được mã hóa lại cho việc hiện thị. Chuỗi mã hóa encoding này có thể là base36 ([a-z ,0-9]) hoặc base62 ([A-Z, a-z, 0-9]) và nếu ta thêm vào các ksi tự ‘+’ và ‘/’ ta có thể sử dụng base64 encoding. 1 Câu hỏi cần được đặt ra là độ dài về định danh short key là bao nhiêu? 6,8,hay 10 kí tự?\nSử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 6 kí tự, sẽ tạo ra được 64^6 = ~68.7 tỷ định danh. Sử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 8 kí tự, sẽ tạo ra được 64^8 = ~281 tỷ tỷ định danh.\nVới 68.7B unique strings, chúng ta giả định là định danh có độ dài là 6 kí tự là đủ cho hệ thống mà ta đang xây dựng.\nNếu ta sử dụng thuật toán MD5 algorithm hay các hash function, nó sẽ tạo ra chuỗi hash có giá trị 128-bit. Sau khi mã hóa base64 encoding, ta sẽ nhận được 1 chuỗi string có nhiều hơn 21 kí tự (do mỗi 1 kí tự base64 sẽ mã hóa 6 bits của chuỗi hash). Dù ta lưạ chọn định danh key có độ dài là 6 hay 8, thì ta vẫn gặp phải vấn đề là trùng lặp key; để giải quyết vấn đề này, ta có thể lựa chọn 1 vài kí tự khác nằm ngoài các chuỗi kí tự dùng để mã hóa.\nNhững issues nào ta sẽ phải đối mặt? Chúng ta sẽ đối mặt với 2 vấn đề với giải pháp mã hóa encoding:\n Nếu có nhiều users cùng nhập vào cùng 1 URL, thì họ sẽ lấy ra cùng 1 shortened URL, điều này là không thể chấp nhận được. Nếu 1 vài phần trong URL là đã được mã hóa URL-encoded thì sao? ví dụ http://www.educative.io/distributed.php?id=design và http://www.educative.io/distributed.php%3Fid%3Ddesign là giống URL trước ở dạng mã hóa URL encoding.  Cách giải quyết các issues: Chúng ta có thể thêm vào 1 chuỗi number tự tăng vào mỗi input URL để nó thành unique và sau đó tạo ra chuỗi hash. Ta không cần lưu trữ chuỗi number tự tăng này vào trong databases. Do đó, các vấn đề có thể gặp phải với cách giải quyết này là chuỗi number tự tăng này ngày càng tăng. Nó có thể tăng mãi mãi? Việc thêm vào 1 chuỗi number tự tăng cũng ảnh hưởng tới hiệu năng của service.\nCách giải quyết khác là thêm vào user id (sẽ là unique) vào input URL. Tuy nhiên, nếu user không đăng nhập, ta sẽ phải yêu cầu user chọn 1 chuỗi key duy nhất. Sau tất cả thì ta vẫn phải đối mặt với 1 mâu thuẫn conflict, ta sẽ phải giữ việc tạo ra định danh key cho tới khi ta tạo ra được 1 chuỗi key unique.\n  b. Tạo định danh keys offline Chúng ta đã có 1 standalone Key Generation Service (KGS) dùng để tạo ra trước các chuỗi 6 ký tự ngẫu nhiên và sau đó lưu trữ chúng vào trong 1 database (ta gọi chúng là key-DB). Bất cứ khi nào chúng ta muốn làm ngắn 1 URL, ta sẽ lấy các keys đã được tạo sẵn trước đó và sử dụng nó. Cách tiếp cận này sẽ khiến mọi thứ trở nên đơn giản và nhanh hơn. Chúng ta không những không cần mã hóa URL mà còn không phải lo lắng về sự trùng lặp hay mâu thuẫn. KGS sẽ đảm bảo mọi keys được insert vào key-DB là duy nhất.\nViệc xử lý song song có gây ra vấn đề gì không? Khi key được sử dụng, nó sẽ được đánh dấu trong database để chắc chắn rằng nó không được sử dụng lại lần nữa. Nếu có nhiều servers cùng đọc keys này vào cùng 1 thời điểm song song, chúng ta sẽ phải đối mặt với ngữ cảnh khi mà có 2 hay nhiều hơn servers cùng đọc cùng 1 key từ database. Cách nào để ta giải quyết vấn đề xử lý song song này?\nServers có thể sử dụng KGS để đọc/đánh dấu các keys trong database. KGS có thể sử dụng 2 tables để lưu trữ keys: 1 tables dùng cho các keys chưa được sử dụng, và 1 table cho tất cả các keys đã được sử dụng. KGS cấp phát các keys cho 1 trong các servers này, và chúng sẽ thực hiện di chuyển key sang bảng table lưu trữ keys đã sử dụng. KGS có thể luôn luôn giữ 1 vài keys trong memory để cấp phát chúng bất cứ khi nào servers cần tới chúng.\nĐể đơn giản, KGS sẽ nạp 1 vài keys vào memory, nó có thể di chuyển chúng sang table chứ các keys đã được sử dụng. Điều này đảm bảo mỗi server sẽ lấy về các unique keys. Nếu KGS dies trước khi gán tất cả các keys đã được loaded tới 1 vài server, chúng ta sẽ lãng phí những keys này–điều này có thể chấp nhận được.\nKGS cũng đảm bảo không cấp phát trùng keys tới nhiều servers. Ví dụ, nó sẽ phải thực hiện đồng bộ (hay lock) cấu trúc dữ liệu data structure dùng để lưu trữ keys trước khi xóa bỏ những keys này khỏi nó vào cấp phát chúng cho 1 server.\nKích thước key-DB này là bao nhiêu? Với base64 encoding, ta có thể tạo ra được 68.7B chuỗi unique keys có độ dài là 6 kí tự. Nếu ta cần 1 byte để lưu trữ 1 kí tự alpha-numeric, thì ta cần:\n6 (characters per key) * 68.7B (unique keys) = 412 GB. KGS có single point of failure nào không? Có. Để giải quyết vấn đề này, ta cần có 1 standby replica của KGS. Bất cứ khi nào, primary server dies thì standby server sẽ thay thế vai trò của nó để tạo và cấp phát keys.\nMỗi app server có thực hiện cache 1 vài keys từ key-DB? Có, điều này có thể tăng tốc. Mặc dù, trong trường hợp này, nếu application server dies trước khi tiêu thụ tất cả các keys, chúng ta sẽ chấp nhận để mất các keys đó. Điều này có thể chấp nhận do chúng ta có 68B unique keys có độ dài là 6 kí tự.\nCách chúng ta thực hiện xử lý key lookup? Ta có thể lookup key trong database để lấy ra full URL. Nếu nó tồn tại trong DB, thì ta sẽ tạo ra “HTTP 302 Redirect” status tới browser, chuyển tiếp stored URL vào trong trường “Location” field của request. Nếu key không tồn tại trong hệ thống, thì ta tạo ra “HTTP 404 Not Found” status hoặc chuyển hướng user về lại homepage.\nTa có nên áp đặt hạn mức size limits vào các định danh tùy chỉnh custom aliases? Dịch vụ của ta có hỗ trợ custom aliases. Users có thể lựa chọn bất cứ định danh ‘key’ nào mà họ thích, nhưng việc cung cấp 1 custom alias là không bắt buộc. Tuy nhiên, ta cần áp đặt hạn mức size limit vào các custom alias để đảm bảo chúng ta có 1 URL database nhất quán. Chúng ta giả định user có thể định nghĩa 1 độ dài tối đa là 16 kí tự trên mỗi customer key (nó đã được phản ánh như trong database schema ở trên)\n7. Phân vùng Data Partitioning và Replication Để mở rộng scale out DB, chúng ta cần phân tán dữ liệu do nó cần chứa hàng tỷ URLs. Do đó, chúng ta cần phát triển 1 partitioning scheme có khả năng phân tán và chia nó và lưu trữ nó ở trên nhiều các DB servers khác nhau.\na. Phân tán dữ liệu theo Range based: ta có thể lưu trữ URLs vào các phân vùng partitions tách biệt dựa vào kí tự đầu tiên của chuỗi hash key. Do đó ta có thể lưu tất cả các URL bất đầu với kí tự ‘A’ hay ‘a’ ở trong 1 phân vùng partition, tương tự lưu các URL bắt đầu với kí tự ‘B’ trong 1 phân vùng partition khác. Cách tiếp cận này được gọi là range-based partitioning. Chúng ta thậm chí có thể nhóm gộp các kí tự ít xuất hiện vào trong cùng 1 database partition. Do đó, chúng ta có thể phát triển 1 static partitioning scheme để luôn lưu trữ/tìm ra 1 URL theo 1 cách dễ đoán định.\nVấn đề chính với cách tiếp cận này là nó có thể dẫn tới việc DB servers không được cân bằng tải. Ví dụ, ta có thể quyết định lưu trữ tất cả URLs bắt đầu với ksi tự ‘E’ vào trong phân vùng 1 DB partition, nhưng nếu sau này khi chúng ta lại có quá nhiều URLs bắt đầu với kí tự ‘E’.\nb. Phân tán dữ liệu theo Hash-Based: Theo schema này, chúng ta tạo ra 1 chuỗi hash của object mà ta đang lưu trữ. Sau đó ta tính toán được phân vùng partition nào được sử dụng dựa trên chuỗi hash. Trong trường hợp của chúng ta, ta có thể lấy hash của định danh ‘key’ hay short link để xác định phân vùng partition dùng để lưu trữ data object.\nHàm hashing function sẽ tạo ra các URLs phân phối ngẫu nhiên vào các phân vùng partitions khác nhau (ví dụ hàm hashing function có thể luôn luôn ánh xạ bất kỳ ‘key’ nào đó với 1 số trong khoảng [1…256]). Số này sẽ biểu thị cho phân vùng partition mà ta lưu trữ object ở trong nó.\nCách tiếp cận này có thể hướng tới việc quá tải overloaded partitions, vấn đề này có thể được giải quyết bằng cách sử dụng Consistent Hashing.\n8. Cache Chúng ta có thể cache các URLs thường xuyên được truy cập. Ta có thể sử dụng bất cứ giải pháp nào có sẵn như Memcached, lưu trữ full URLs với chuỗi định danh hashes tương ứng của nó. Do vậy, application servers, trước khi hitting vào backend storage, chúng ta có thể nhanh chóng kiểm tra được nếu cache có chứa URL đang được request.\nBao nhiêu cache memory mà ta sẽ sử dụng? Chúng ta có thể bắt đầu dựa trên 20% traffic truy cập hàng ngày và dựa trên ước lượng sử dụng của client, ta có thể biết được bao nhiêu cache servers mà ta cần. Giống như việc định lượng ở trên, chúng ta cần 170GB memory để cache 20% daily traffic. Do các server hiện đại ngày nay có thể có tới 256GB memory, nên ta có thể dễ dàng chứa tất cả các cache của hệ thống trên 1 máy. Hay cách khác, ta có thể sử dụng 1 nhóm các servers nhỏ hơn để chứa các hot URLs này.\nChính sach loại bỏ cache nào sẽ phù hợp nhất với yêu cầu hệ thống? Khi cache đầy, và ta muốn thay thế 1 link với 1 URL mới hay hot hơn, ta sẽ làm điều này bằng cách nào? Chính sách Least Recently Used (LRU) có thể phù hợp với hệ thống. Với chính sách này ta có thể loại bỏ các URL ít được sử dụng gần đây nhất. Ta có thể sử dụng cấu trúc dữ liệu Linked Hash Map hay cấu trúc dữ liệu tương tụ để lưu trữ các URLs và các định danh Hashes, cấu trúc này sẽ trợ giúp ta track được các URLs mà được truy cập gần đây.\nĐể tăng hiệu quả, ta có thể nhân bản replicate các caching servers để phân phối tải load giữa chúng.\nCách mà mỗi cache replica được cập nhật? Bất cứ khi nào cache miss, servers sẽ hitting vào backend database. Bất cứ khi nào việc này xảy ra, ta có thể cập nhật cache và chuyển tiếp dữ liệu mới vào tất cả các cache replicas. Mỗi replica có thể cập nhật cache của nó bằng cách thêm vào dữ liệu mới. Nếu 1 replica đã có dữ liệu này, thì nó có thể đơn giản từ chỗi cập nhật.\n  9. Cân bằng tải Load Balancer (LB) Ta có thể thêm 1 lớp cân bằng tải Load balancing layer vào 3 vị trí sau trong hệ thống:\n Giữa Clients và Application servers. Giữa Application Servers và database servers. Giữa Application Servers và Cache servers.  Đầu tiên, ta có thể sử dụng cách tiếp cận Round Robin đơn giản để phân phối các incoming requests cân bằng giữa các backend servers. Đây là cách cân bằng tải LB đơn giản để thực thi. 1 ưu điểm khác của cách tiếp cận này là nếu 1 server chết thì LB sẽ loại bỏ nó ra khoản nhóm vòng xoay và sẽ ngừng gửi traffic tới nó.\n1 vấn đề phát sinh với Round Robin LB là nó không quan tâm tới tải server load. Do vậy, nếu 1 server bị quá tải hay bị chậm thì LB sẽ không ngừng gửi request mới tới server đó. Để khắc phục vấn đề này, 1 giải pháp LB thông minh hơn có thể được áp dụng là LB sẽ định kỳ truy vấn về tải của backend server và điểu chỉnh traffic dựa vào đó.\n10. Thanh lọc và dọn dẹp DB Các dữ liệu có nên tồn tại mãi mãi hay nên được thanh lọc? Nếu thời gian hết hạn do user định nghĩa đã đến thì điều gì cần nên làm với các link hết hạn này?\nNếu ta chọn cách liên tục tìm kiếm các links đã hết hạn để xóa chúng, thì nó gây sức ép lớn đến database. Thay vào đó, ta có thể chậm rãi xóa bỏ các links cũ đã hết hạn này bằng cách dọn dẹp kiểu lazy cleanup. Service của chúng ta cũng cần chắc chắn với các links hết hạn thì sẽ được xóa dù 1 vài links đã hết hạn vẫn sống lâu hơn nhưng nó sẽ không bao giờ được trả về cho users.\n Bất cứ khi nào user thử truy cập vào 1 link hết hạn, ta có thể xóa link này và trả về lỗi cho user. 1 Cleanup service độc lập sẽ chạy định kỳ để xóa các links đã hết hạn ra khỏi storage và cache. Service này sẽ rất nhẹ và được lập lịch chạy vào thời điểm mà user traffice thấp. Ta luôn có 1 ngưỡng thời gian hết hạn cho từng link (ví dụ: 2 năm). Sau khi xóa 1 link đã hết hạn, ta có thể lưu lại key trở lại key-DB để tái sử dụng lại. Ta cũng nên xoá các links mà không được truy cập sau 1 khoảng thời gian, ví dụ như 6 tháng? Đây có thể là 1 mẹo. Do lưu trữ storage tương đối rẻ, ta cũng có thể quyết định lưu trữ links mãi mãi.  11. Telemetry Có tổng số bao nhiêu lần 1 short URL được sử dụng, hay user truy cập chúng từ đâu? Cách mà ta sẽ lưu trữ các thống kê này? Nếu mỗi lần có 1 view mới ta lại thực hiện cập nhật 1 DB row, thì điều gì sẽ xảy ra khi 1 URL phổ biến có 1 lượng lớn các concurrent requests?\nMột vài thống kê khác cũng đáng để theo dõi: quốc gia của các visitor, thời điểm của các truy cập, các web page tham chiếu tới, browser, hay platform của các visitor.\n12. Bảo mật và quyền hạn Security và Permissions Users có thể tạo ra các private URLs hay cho phép 1 tập các users cụ thể nào đó được phép truy cập URL?\nChúng ta có thể lưu trữ mức quyền hạn permission level (public/private) với từng URL trong database. Ta có thể tạo ra 1 bảng table riêng để lưu trữ các UserIDs có quyền truy cập 1 URL cụ thể. Nếu 1 user không có quyền hay cố gắng truy cập vào 1 URL, ta có thể gửi 1 lỗi (HTTP 401). Như đã trình bày ở trên, chúng ta đang lưu trữ dữ liệu trong NoSQL wide-column database như Cassandra, khóa key cho table lưu trữ quyền hạn permissions sẽ là ‘Hash’ hay chuỗi do KGS sinh ra. Cột này sẽ lưu trữ giá trị của các UserIDs được phép truy cập URL.\n","wordCount":"4343","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"telion"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/"},"publisher":{"@type":"Organization","name":"LifeSucks","logo":{"@type":"ImageObject","url":"https://lifesucks.dev/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://lifesucks.dev/ accesskey=h title="LifeSucks (Alt + H)">LifeSucks</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://lifesucks.dev/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/series/ title=Series>
<span>Series</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://lifesucks.dev/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://lifesucks.dev/>Home</a>&nbsp;»&nbsp;<a href=https://lifesucks.dev/posts/>Posts</a></div>
<h1 class=post-title>
Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL
</h1>
<div class=post-description>
Chúng ta sẽ cùng nhau thiết kế 1 dịch vụ URL Shortening service giống như TinyURL. Dịch vụ này sẽ cung cấp các định danh ngắn gọn dùng để điều hướng tới các URLs dài
</div>
<div class=post-meta>21 min&nbsp;·&nbsp;telion&nbsp;|&nbsp;<a href=https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/grokking-system-design-interviews/Designing%20a%20URL%20Shortening%20service%20like%20TinyURL.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#1-t%e1%ba%a1i-sao-ch%c3%bang-ta-c%e1%ba%a7n-1-d%e1%bb%8bch-v%e1%bb%a5-ki%e1%bb%83u-l%c3%a0m-ng%e1%ba%afn-url-shortening aria-label="1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening?">1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening?</a></li>
<li>
<a href=#2-y%c3%aau-c%e1%ba%a7u-v%c3%a0-m%e1%bb%a5c-ti%c3%aau-c%e1%bb%a7a-h%e1%bb%87-th%e1%bb%91ng aria-label="2. Yêu cầu và mục tiêu của hệ thống">2. Yêu cầu và mục tiêu của hệ thống</a></li>
<li>
<a href=#3-%c4%91%e1%bb%8bnh-l%c6%b0%e1%bb%a3ng-s%e1%bb%a9c-ch%e1%bb%a9a-v%c3%a0-c%c3%a1c-r%c3%a0ng-bu%e1%bb%99c aria-label="3. Định lượng sức chứa và các ràng buộc">3. Định lượng sức chứa và các ràng buộc</a></li>
<li>
<a href=#4-system-apis aria-label="4. System APIs">4. System APIs</a></li>
<li>
<a href=#5-database-design aria-label="5. Database Design">5. Database Design</a><ul>
<li>
<a href=#database-schema aria-label="Database schema">Database schema</a></li></ul>
</li>
<li>
<a href=#6-basic-system-design-v%c3%a0-algorithm aria-label="6. Basic System Design và Algorithm">6. Basic System Design và Algorithm</a><ul>
<li>
<a href=#a-m%c3%a3-h%c3%b3a-url-g%e1%bb%91c aria-label="a. Mã hóa URL gốc">a. Mã hóa URL gốc</a></li>
<li>
<a href=#b-t%e1%ba%a1o-%c4%91%e1%bb%8bnh-danh-keys-offline aria-label="b. Tạo định danh keys offline">b. Tạo định danh keys offline</a></li></ul>
</li>
<li>
<a href=#7-ph%c3%a2n-v%c3%b9ng-data-partitioning-v%c3%a0-replication aria-label="7. Phân vùng Data Partitioning và Replication">7. Phân vùng Data Partitioning và Replication</a></li>
<li>
<a href=#8-cache aria-label="8. Cache">8. Cache</a></li>
<li>
<a href=#9-c%c3%a2n-b%e1%ba%b1ng-t%e1%ba%a3i-load-balancer-lb aria-label="9. Cân bằng tải Load Balancer (LB)">9. Cân bằng tải Load Balancer (LB)</a></li>
<li>
<a href=#10-thanh-l%e1%bb%8dc-v%c3%a0-d%e1%bb%8dn-d%e1%ba%b9p-db aria-label="10. Thanh lọc và dọn dẹp DB">10. Thanh lọc và dọn dẹp DB</a></li>
<li>
<a href=#11-telemetry aria-label="11. Telemetry">11. Telemetry</a></li>
<li>
<a href=#12-b%e1%ba%a3o-m%e1%ba%adt-v%c3%a0-quy%e1%bb%81n-h%e1%ba%a1n-security-v%c3%a0-permissions aria-label="12. Bảo mật và quyền hạn Security và Permissions">12. Bảo mật và quyền hạn Security và Permissions</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=1-tại-sao-chúng-ta-cần-1-dịch-vụ-kiểu-làm-ngắn-url-shortening>1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening?<a hidden class=anchor aria-hidden=true href=#1-tại-sao-chúng-ta-cần-1-dịch-vụ-kiểu-làm-ngắn-url-shortening>#</a></h2>
<p>URL shortening được sử dụng để tạo ra các định danh ngắn gọn hơn shorter aliases cho các URLs dài dòng. Chúng ta gọi các định danh được làm ngắn này là các &ldquo;short links.&rdquo;. Các users được điều hướng tới URL gốc khi họ thực hiện truy cập vào các short links này. Các short links sẽ tiết kiệm nhiều không gian khi hiện thị, in ấn, truyền thông điệp hay tweeted. Thêm nữa, các users thường hiếm khi gõ sai khi thực hiện gõ các URLs được làm ngắn gọn lại.</p>
<p>Ví dụ, nếu chúng ta làm ngắn URL sau thông qua TinyURL:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>https://www.educative.io/courses/grokking-the-system-design-interview/m2ygV4E81AR
</code></pre></div><p>Chúng ta sẽ nhận được kết quả:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>https://tinyurl.com/rxcsyr3r
</code></pre></div><p>URL được làm ngắn chỉ bằng 1 phần 3 so với URL gốc.
Hệ thống URL shortening được sử dụng để tối ưu links thông qua nhiều thiết bị devices, có thể track được các links cụ thể để phân tích audience, đo lường hiệu quả của chiến dịch quảng cáo, hay dùng để ẩn đi URLs gốc.</p>
<p>Nếu bạn chưa từng sử dụng tinyurl.com trước đây, bạn nên thử tạo ra 1 shortened URL và bỏ thời gian để sử dụng 1 số options khác nhau do dịch vụ cung cấp. Nó sẽ giúp bạn hiểu về chương này.</p>
<h2 id=2-yêu-cầu-và-mục-tiêu-của-hệ-thống>2. Yêu cầu và mục tiêu của hệ thống<a hidden class=anchor aria-hidden=true href=#2-yêu-cầu-và-mục-tiêu-của-hệ-thống>#</a></h2>
<blockquote>
<p>Bạn phải luôn luôn làm rõ các yêu cầu ngay từ thời điểm bắt đầu của buổi phỏng vấn. Và đảm bảo chắc chắn rằng đặt ra các câu hỏi để tìm ra chính xác phạm vi scope của hệ thống.</p>
</blockquote>
<p>Hệ thống URL shortening system sẽ có các yêu cầu như sau:
<strong>Các yêu cầu về mặt tính năng:</strong></p>
<ol>
<li>Đưa ra 1 URL, dịch vụ của chúng ta sẽ tạo ra 1 định danh ngắn hơn và duy nhất cho nó. Định danh này được gọi là 1 short link. Link này được làm ngắn gọn đủ để dễ dàng khi thực hiện copied và pasted vào trong các ứng dụng applications.</li>
<li>Khi users truy cập 1 short link, dịch vụ của chúng ta sẽ điều hướng họ tới link gốc.</li>
<li>Các users có thể tùy chọn cấu hình tùy chỉnh custom short link cho URL của họ.</li>
<li>Các links sẽ bị hết hạn sau 1 khoảng thời gian. Các users có thể định nghĩa được thời gian hết hạn này.</li>
</ol>
<p><strong>Các yêu cầu không liên quan tới tính năng:</strong></p>
<ol>
<li>Hệ thống phải có tính sẵn sàng cao. Đây là yêu cầu bắt buộc bởi vì khi hệ thống bị down, thì tất cả các chuyển hướng URL sẽ gặp lỗi.</li>
<li>Chuyển hướng URL nên xảy ra theo thời gian thực với độ trễ thấp.</li>
<li>Các Shortened links nên được tạo ra 1 cách bất định (khó đoán trước).</li>
</ol>
<p><strong>Các yêu cầu mở rộng:</strong></p>
<ol>
<li>Phân tích Analytics, ví dụ 1 url được chuyển hướng bao nhiêu lần?</li>
<li>Dịch vụ nên được truy cập được thông qua REST APIs bởi các services khác.</li>
</ol>
<h2 id=3-định-lượng-sức-chứa-và-các-ràng-buộc>3. Định lượng sức chứa và các ràng buộc<a hidden class=anchor aria-hidden=true href=#3-định-lượng-sức-chứa-và-các-ràng-buộc>#</a></h2>
<p>Hệ thống của ta sẽ nặng về read. Sẽ có rất nhiều chuyển hướng redirection requests so với các new URL shortenings. Ta giải định tỉ lệ này khoảng 100:1 giữa read và write.</p>
<p><strong>Định lượng traffic:</strong> Giả sử, chúng ta sẽ có 500M new URL shortenings mới mỗi tháng, với tỉ lệ 100:1 read/write, ta kì vọng có 50B (50 tỷ) chuyển hướng redirections với cùng chu kỳ:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>100*500M <span style=color:#f92672>=</span>&gt; 50B
</code></pre></div><p>Số lượng truy vấn trên giây Queries Per Second (QPS) là bao nhiêu? New URLs shortenings được làm ngắn trên mỗi giây:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>500</span> million / <span style=color:#f92672>(</span><span style=color:#ae81ff>30</span> days * <span style=color:#ae81ff>24</span> hours * <span style=color:#ae81ff>3600</span> seconds<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> ~200 URLs/s
</code></pre></div><p>Xét tới tỉ lệ 100:1 read/write, URLs redirections trên mỗi giây sẽ là:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>100</span> * <span style=color:#ae81ff>200</span> URLs/s <span style=color:#f92672>=</span> 20K/s
</code></pre></div><p><strong>Định lượng lưu trữ storage:</strong> Giả sử ta lưu trữ mọi URL shortening request (bao gồm cả shortened link tương ứng với nó) trong vòng 5 năm. Do ta kỳ vọng có 500M new URLs mỗi tháng, thì tổng số objects mà ta kỳ vọng lưu trữ là 30B (30 tỷ):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>500</span> million * <span style=color:#ae81ff>5</span> years * <span style=color:#ae81ff>12</span> months <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span> billion
</code></pre></div><p>Ta giả định mỗi object được lưu trữ mất xấp xỉ 500 bytes. Ta sẽ cần 15TB lưu trữ storage:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>30</span> billion * <span style=color:#ae81ff>500</span> bytes <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span> TB
</code></pre></div><p><strong>Định lượng băng thông Bandwidth:</strong> Với các write requests, do chúng ta kỳ vọng 200 new URLs trên mỗi giây, tổng số dữ liệu incoming data sẽ khoảng 100KB trên giây:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>200</span> * <span style=color:#ae81ff>500</span> bytes <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span> KB/s
</code></pre></div><p>Với các read requests, do mỗi giây ra kỳ vọng ~ 20K chuyển hướng URLs redirections, tổng số dữ liệu outgoing data sẽ khoảng 10MB trên giây:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>20K * <span style=color:#ae81ff>500</span> bytes <span style=color:#f92672>=</span> ~10 MB/s
</code></pre></div><p><strong>Định lượng memory:</strong> Nếu ta muốn cache 1 vài hot URLs mà thường xuyên được truy cập, số lượng memory và ta cần để lưu trữ chúng là bao nhiêu? Nếu ta tuân theo định luật 80-20 rule, có nghĩa là 20% số URLs sẽ tạo ra 80% traffic, Chúng ta sẽ muốn cache lại 20% hot URLs.
Do ta có khoảng 20K requests trên giây, ta sẽ có khoảng 1.7B (tỷ) requests mỗi ngày:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>20K * <span style=color:#ae81ff>3600</span> seconds * <span style=color:#ae81ff>24</span> hours <span style=color:#f92672>=</span> ~1.7 billion
</code></pre></div><p>Ta sẽ cache lại 20% số requests này, ta sẽ cần 170GB memory:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>0.2 * 1.7 billion * <span style=color:#ae81ff>500</span> bytes <span style=color:#f92672>=</span> ~170GB
</code></pre></div><p>1 điểm nữa ta cần lưu ý ở đây là sẽ có nhiều duplicate requests tới cùng 1 URL, nên số lượng memory mà ta sử dụng sẽ thấp hơn 170GB.
<strong>Định lượng ở mức High-level:</strong> Giả định có 500M new URLs mỗi tháng và tỷ lệ 100:1 read:write, bảng sau đây sẽ chỉ ra định lượng tổng quan của service:</p>
<table>
<thead>
<tr>
<th>Chỉ số</th>
<th>Định lượng</th>
</tr>
</thead>
<tbody>
<tr>
<td>New URLS</td>
<td>200/s</td>
</tr>
<tr>
<td>URL redirections</td>
<td>20k/s</td>
</tr>
<tr>
<td>Incoming data</td>
<td>100KB/s</td>
</tr>
<tr>
<td>Outgoing data</td>
<td>10MB/s</td>
</tr>
<tr>
<td>Storage for 5 years</td>
<td>15TB</td>
</tr>
<tr>
<td>Memory for cache</td>
<td>170GB</td>
</tr>
</tbody>
</table>
<h2 id=4-system-apis>4. System APIs<a hidden class=anchor aria-hidden=true href=#4-system-apis>#</a></h2>
<blockquote>
<p>Khi chúng ta đã hoàn thành việc làm rõ yêu cầu, sẽ luôn là 1 ý tưởng tốt để định nghĩa ra các system APIs. Do đây đúng là những gì mà hệ thống kỳ vọng</p>
</blockquote>
<p>Chúng ta có thể tạo ra SOAP hay REST APIs để lộ ra các tính năng của hệ thống. Đoạn mã dưới đây định nghĩa APIs dùng để tạo mới và xóa URLs:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>createURL<span style=color:#f92672>(</span>api_dev_key, original_url, custom_alias<span style=color:#f92672>=</span>None, user_name<span style=color:#f92672>=</span>None, expire_date<span style=color:#f92672>=</span>None<span style=color:#f92672>)</span>
</code></pre></div><p><strong>Các tham số:</strong></p>
<ul>
<li>api_dev_key (string): API developer key của 1 account đã đăng ký. Nó sẽ được sử dụng cho nhiều mục đích khác như việc giới hạn gọi api của users dựa trên quota được cấp.</li>
<li>original_url (string): URL gốc được làm ngắn</li>
<li>custom_alias (string): custom key tùy chọn cho URL.</li>
<li>user_name (string): tùy chọn user name được dùng để mã hóa encoding.</li>
<li>expire_date (string): tùy chọn ngày hết hạn cho shortened URL.</li>
</ul>
<p><strong>Return:(string)</strong>
Khi việc thêm mới thành công nó sẽ trả về shortened URL; mặt khác nó sẽ trả về 1 mã lỗi error code.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>deleteURL<span style=color:#f92672>(</span>api_dev_key, url_key<span style=color:#f92672>)</span>
</code></pre></div><p>Với <code>url_key</code> là chuỗi biểu thị shortened URL được trả về; Nếu xóa thành công sẽ trả về &ldquo;URL Removed&rdquo;.
<strong>Cách mà ta phát hiện và ngăn chặn việc lạm quyền?</strong> Để ngăn chặn điều này, ta có thể giới hạn users thông qua <code>api_dev_key</code>. Mỗi <code>api_dev_key</code> có thể bị giới hạn 1 số lượng tạo URL creations hay chuyển hướng redirections trên 1 khoảng thời gian (Điều này có thể được thiết lập các khoảng thời gian khác nhau trên mỗi developer key).</p>
<h2 id=5-database-design>5. Database Design<a hidden class=anchor aria-hidden=true href=#5-database-design>#</a></h2>
<blockquote>
<p>Định nghĩa DB schema trong những bước đầu tiên của buổi phỏng vấn sẽ giúp hiểu được về luồng data flow giữa các thành phần components khác nhau trong hệ thống và từ đó nó sẽ hướng chúng ta tới việc quy hoạch phân vùng dữ liệu.</p>
</blockquote>
<p>Có 1 vài quan sát về bản chất dữ liệu mà chúng ta sẽ lưu trữ như sau:</p>
<ol>
<li>Chúng ta cần lưu trữ hàng tỷ bản ghi.</li>
<li>Mỗi object chúng ta lưu trữ thường rất nhỏ (nhỏ hơn 1K).</li>
<li>Không có mối quan hệ relationships giữa các bản ghi records&ndash;hơn là việc cần lưu lại user nào tạo ra URL.</li>
<li>Service thiên về read.</li>
</ol>
<h3 id=database-schema>Database schema<a hidden class=anchor aria-hidden=true href=#database-schema>#</a></h3>
<p>Chúng ta cần có 2 bảng tables: 1 dùng để lưu trữ thông tin về URL mapping và 1 bảng lưu trữ về thông tin user data người đã tạo ra short link.</p>
<p><img loading=lazy src=/grokking-system-design-interviews/5932826461995008.svg alt="High-level design diagram" title="High-level design diagram">
</p>
<p>Loại database nào mà ta nên sử dụng? Do ta ước tính cần lưu trữ hàng tỷ bản ghi và ta không cần sử dụng mối quan hệ relationships giữa các objects - 1 NoSQL giống như DynamoDB, Cassandra hay Riak là lựa chọn phù hợp. Lựa chọn theo hướng NoSQL sẽ giúp dễ dàng mở rộng scale hơn.</p>
<h2 id=6-basic-system-design-và-algorithm>6. Basic System Design và Algorithm<a hidden class=anchor aria-hidden=true href=#6-basic-system-design-và-algorithm>#</a></h2>
<p>Vấn đề mà ta muốn giải quyết tại đây là cách tạo ra 1 định danh ngắn gọn và duy nhất cho 1 URL nào đó.
Trong ví dụ về TinyURL ở phần 1, shortened URL có giá trị là &ldquo;<a href=https://tinyurl.com/rxcsyr3r%22>https://tinyurl.com/rxcsyr3r"</a>. 8 kí tự cuối trong chuỗi URL này chính là định danh mà ta muốn tạo. Ta sẽ đưa ra 2 giải pháp tại đây:</p>
<h3 id=a-mã-hóa-url-gốc>a. Mã hóa URL gốc<a hidden class=anchor aria-hidden=true href=#a-mã-hóa-url-gốc>#</a></h3>
<p>Ta có thể tạo ra 1 chuỗi unique hash (MD5 hay SHA256) từ 1 URL đã cho. Chuỗi hash có thể được mã hóa lại cho việc hiện thị. Chuỗi mã hóa encoding này có thể là base36 ([a-z ,0-9]) hoặc base62 ([A-Z, a-z, 0-9]) và nếu ta thêm vào các ksi tự &lsquo;+&rsquo; và &lsquo;/&rsquo; ta có thể sử dụng base64 encoding. 1 Câu hỏi cần được đặt ra là độ dài về định danh short key là bao nhiêu? 6,8,hay 10 kí tự?</p>
<p>Sử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 6 kí tự, sẽ tạo ra được 64^6 = ~68.7 tỷ định danh.
Sử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 8 kí tự, sẽ tạo ra được 64^8 = ~281 tỷ tỷ định danh.</p>
<p>Với 68.7B unique strings, chúng ta giả định là định danh có độ dài là 6 kí tự là đủ cho hệ thống mà ta đang xây dựng.</p>
<p>Nếu ta sử dụng thuật toán MD5 algorithm hay các hash function, nó sẽ tạo ra chuỗi hash có giá trị 128-bit. Sau khi mã hóa base64 encoding, ta sẽ nhận được 1 chuỗi string có nhiều hơn 21 kí tự (do mỗi 1 kí tự base64 sẽ mã hóa 6 bits của chuỗi hash). Dù ta lưạ chọn định danh key có độ dài là 6 hay 8, thì ta vẫn gặp phải vấn đề là trùng lặp key; để giải quyết vấn đề này, ta có thể lựa chọn 1 vài kí tự khác nằm ngoài các chuỗi kí tự dùng để mã hóa.</p>
<p><strong>Những issues nào ta sẽ phải đối mặt?</strong> Chúng ta sẽ đối mặt với 2 vấn đề với giải pháp mã hóa encoding:</p>
<ol>
<li>Nếu có nhiều users cùng nhập vào cùng 1 URL, thì họ sẽ lấy ra cùng 1 shortened URL, điều này là không thể chấp nhận được.</li>
<li>Nếu 1 vài phần trong URL là đã được mã hóa URL-encoded thì sao? ví dụ <code>http://www.educative.io/distributed.php?id=design</code> và <code>http://www.educative.io/distributed.php%3Fid%3Ddesign</code> là giống URL trước ở dạng mã hóa URL encoding.</li>
</ol>
<p><strong>Cách giải quyết các issues:</strong> Chúng ta có thể thêm vào 1 chuỗi number tự tăng vào mỗi input URL để nó thành unique và sau đó tạo ra chuỗi hash. Ta không cần lưu trữ chuỗi number tự tăng này vào trong databases. Do đó, các vấn đề có thể gặp phải với cách giải quyết này là chuỗi number tự tăng này ngày càng tăng. Nó có thể tăng mãi mãi? Việc thêm vào 1 chuỗi number tự tăng cũng ảnh hưởng tới hiệu năng của service.</p>
<p>Cách giải quyết khác là thêm vào user id (sẽ là unique) vào input URL. Tuy nhiên, nếu user không đăng nhập, ta sẽ phải yêu cầu user chọn 1 chuỗi key duy nhất. Sau tất cả thì ta vẫn phải đối mặt với 1 mâu thuẫn conflict, ta sẽ phải giữ việc tạo ra định danh key cho tới khi ta tạo ra được 1 chuỗi key unique.</p>
<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden>
<iframe src=https://www.youtube-nocookie.com/embed/ZrnYOStAwsM style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="Request flow for shortening of a URL"></iframe>
</div>
<h3 id=b-tạo-định-danh-keys-offline>b. Tạo định danh keys offline<a hidden class=anchor aria-hidden=true href=#b-tạo-định-danh-keys-offline>#</a></h3>
<p>Chúng ta đã có 1 standalone <strong>Key Generation Service (KGS)</strong> dùng để tạo ra trước các chuỗi 6 ký tự ngẫu nhiên và sau đó lưu trữ chúng vào trong 1 database (ta gọi chúng là key-DB). Bất cứ khi nào chúng ta muốn làm ngắn 1 URL, ta sẽ lấy các keys đã được tạo sẵn trước đó và sử dụng nó. Cách tiếp cận này sẽ khiến mọi thứ trở nên đơn giản và nhanh hơn. Chúng ta không những không cần mã hóa URL mà còn không phải lo lắng về sự trùng lặp hay mâu thuẫn. KGS sẽ đảm bảo mọi keys được insert vào key-DB là duy nhất.</p>
<p><strong>Việc xử lý song song có gây ra vấn đề gì không?</strong> Khi key được sử dụng, nó sẽ được đánh dấu trong database để chắc chắn rằng nó không được sử dụng lại lần nữa. Nếu có nhiều servers cùng đọc keys này vào cùng 1 thời điểm song song, chúng ta sẽ phải đối mặt với ngữ cảnh khi mà có 2 hay nhiều hơn servers cùng đọc cùng 1 key từ database. Cách nào để ta giải quyết vấn đề xử lý song song này?</p>
<p>Servers có thể sử dụng KGS để đọc/đánh dấu các keys trong database. KGS có thể sử dụng 2 tables để lưu trữ keys: 1 tables dùng cho các keys chưa được sử dụng, và 1 table cho tất cả các keys đã được sử dụng. KGS cấp phát các keys cho 1 trong các servers này, và chúng sẽ thực hiện di chuyển key sang bảng table lưu trữ keys đã sử dụng. KGS có thể luôn luôn giữ 1 vài keys trong memory để cấp phát chúng bất cứ khi nào servers cần tới chúng.</p>
<p>Để đơn giản, KGS sẽ nạp 1 vài keys vào memory, nó có thể di chuyển chúng sang table chứ các keys đã được sử dụng. Điều này đảm bảo mỗi server sẽ lấy về các unique keys. Nếu KGS dies trước khi gán tất cả các keys đã được loaded tới 1 vài server, chúng ta sẽ lãng phí những keys này&ndash;điều này có thể chấp nhận được.</p>
<p>KGS cũng đảm bảo không cấp phát trùng keys tới nhiều servers. Ví dụ, nó sẽ phải thực hiện đồng bộ (hay lock) cấu trúc dữ liệu data structure dùng để lưu trữ keys trước khi xóa bỏ những keys này khỏi nó vào cấp phát chúng cho 1 server.</p>
<p><strong>Kích thước key-DB này là bao nhiêu?</strong> Với base64 encoding, ta có thể tạo ra được 68.7B chuỗi unique keys có độ dài là 6 kí tự. Nếu ta cần 1 byte để lưu trữ 1 kí tự alpha-numeric, thì ta cần:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>6</span> <span style=color:#f92672>(</span>characters per key<span style=color:#f92672>)</span> * 68.7B <span style=color:#f92672>(</span>unique keys<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>412</span> GB.
</code></pre></div><p><strong>KGS có single point of failure nào không?</strong> Có. Để giải quyết vấn đề này, ta cần có 1 standby replica của KGS. Bất cứ khi nào, primary server dies thì standby server sẽ thay thế vai trò của nó để tạo và cấp phát keys.</p>
<p><strong>Mỗi app server có thực hiện cache 1 vài keys từ key-DB?</strong> Có, điều này có thể tăng tốc. Mặc dù, trong trường hợp này, nếu application server dies trước khi tiêu thụ tất cả các keys, chúng ta sẽ chấp nhận để mất các keys đó. Điều này có thể chấp nhận do chúng ta có 68B unique keys có độ dài là 6 kí tự.</p>
<p><strong>Cách chúng ta thực hiện xử lý key lookup?</strong> Ta có thể lookup key trong database để lấy ra full URL. Nếu nó tồn tại trong DB, thì ta sẽ tạo ra “HTTP 302 Redirect” status tới browser, chuyển tiếp stored URL vào trong trường “Location” field của request. Nếu key không tồn tại trong hệ thống, thì ta tạo ra “HTTP 404 Not Found” status hoặc chuyển hướng user về lại homepage.</p>
<p><strong>Ta có nên áp đặt hạn mức size limits vào các định danh tùy chỉnh custom aliases?</strong> Dịch vụ của ta có hỗ trợ custom aliases. Users có thể lựa chọn bất cứ định danh &lsquo;key&rsquo; nào mà họ thích, nhưng việc cung cấp 1 custom alias là không bắt buộc. Tuy nhiên, ta cần áp đặt hạn mức size limit vào các custom alias để đảm bảo chúng ta có 1 URL database nhất quán. Chúng ta giả định user có thể định nghĩa 1 độ dài tối đa là 16 kí tự trên mỗi customer key (nó đã được phản ánh như trong database schema ở trên)</p>
<p><img loading=lazy src=/grokking-system-design-interviews/5369668320100352.svg alt="High level system design for URL shortening" title="High level system design for URL shortening">
</p>
<h2 id=7-phân-vùng-data-partitioning-và-replication>7. Phân vùng Data Partitioning và Replication<a hidden class=anchor aria-hidden=true href=#7-phân-vùng-data-partitioning-và-replication>#</a></h2>
<p>Để mở rộng scale out DB, chúng ta cần phân tán dữ liệu do nó cần chứa hàng tỷ URLs. Do đó, chúng ta cần phát triển 1 partitioning scheme có khả năng phân tán và chia nó và lưu trữ nó ở trên nhiều các DB servers khác nhau.</p>
<p><strong>a. Phân tán dữ liệu theo Range based</strong>: ta có thể lưu trữ URLs vào các phân vùng partitions tách biệt dựa vào kí tự đầu tiên của chuỗi hash key. Do đó ta có thể lưu tất cả các URL bất đầu với kí tự &lsquo;A&rsquo; hay &lsquo;a&rsquo; ở trong 1 phân vùng partition, tương tự lưu các URL bắt đầu với kí tự &lsquo;B&rsquo; trong 1 phân vùng partition khác. Cách tiếp cận này được gọi là range-based partitioning. Chúng ta thậm chí có thể nhóm gộp các kí tự ít xuất hiện vào trong cùng 1 database partition. Do đó, chúng ta có thể phát triển 1 static partitioning scheme để luôn lưu trữ/tìm ra 1 URL theo 1 cách dễ đoán định.</p>
<p>Vấn đề chính với cách tiếp cận này là nó có thể dẫn tới việc DB servers không được cân bằng tải. Ví dụ, ta có thể quyết định lưu trữ tất cả URLs bắt đầu với ksi tự &lsquo;E&rsquo; vào trong phân vùng 1 DB partition, nhưng nếu sau này khi chúng ta lại có quá nhiều URLs bắt đầu với kí tự &lsquo;E&rsquo;.</p>
<p><strong>b. Phân tán dữ liệu theo Hash-Based</strong>: Theo schema này, chúng ta tạo ra 1 chuỗi hash của object mà ta đang lưu trữ. Sau đó ta tính toán được phân vùng partition nào được sử dụng dựa trên chuỗi hash. Trong trường hợp của chúng ta, ta có thể lấy hash của định danh &lsquo;key&rsquo; hay short link để xác định phân vùng partition dùng để lưu trữ data object.</p>
<p>Hàm hashing function sẽ tạo ra các URLs phân phối ngẫu nhiên vào các phân vùng partitions khác nhau (ví dụ hàm hashing function có thể luôn luôn ánh xạ bất kỳ &lsquo;key&rsquo; nào đó với 1 số trong khoảng [1&mldr;256]). Số này sẽ biểu thị cho phân vùng partition mà ta lưu trữ object ở trong nó.</p>
<p>Cách tiếp cận này có thể hướng tới việc quá tải overloaded partitions, vấn đề này có thể được giải quyết bằng cách sử dụng Consistent Hashing.</p>
<h2 id=8-cache>8. Cache<a hidden class=anchor aria-hidden=true href=#8-cache>#</a></h2>
<p>Chúng ta có thể cache các URLs thường xuyên được truy cập. Ta có thể sử dụng bất cứ giải pháp nào có sẵn như Memcached, lưu trữ full URLs với chuỗi định danh hashes tương ứng của nó. Do vậy, application servers, trước khi hitting vào backend storage, chúng ta có thể nhanh chóng kiểm tra được nếu cache có chứa URL đang được request.</p>
<p><strong>Bao nhiêu cache memory mà ta sẽ sử dụng?</strong> Chúng ta có thể bắt đầu dựa trên 20% traffic truy cập hàng ngày và dựa trên ước lượng sử dụng của client, ta có thể biết được bao nhiêu cache servers mà ta cần. Giống như việc định lượng ở trên, chúng ta cần 170GB memory để cache 20% daily traffic. Do các server hiện đại ngày nay có thể có tới 256GB memory, nên ta có thể dễ dàng chứa tất cả các cache của hệ thống trên 1 máy. Hay cách khác, ta có thể sử dụng 1 nhóm các servers nhỏ hơn để chứa các hot URLs này.</p>
<p><strong>Chính sach loại bỏ cache nào sẽ phù hợp nhất với yêu cầu hệ thống?</strong> Khi cache đầy, và ta muốn thay thế 1 link với 1 URL mới hay hot hơn, ta sẽ làm điều này bằng cách nào? Chính sách Least Recently Used (LRU) có thể phù hợp với hệ thống. Với chính sách này ta có thể loại bỏ các URL ít được sử dụng gần đây nhất. Ta có thể sử dụng cấu trúc dữ liệu Linked Hash Map hay cấu trúc dữ liệu tương tụ để lưu trữ các URLs và các định danh Hashes, cấu trúc này sẽ trợ giúp ta track được các URLs mà được truy cập gần đây.</p>
<p>Để tăng hiệu quả, ta có thể nhân bản replicate các caching servers để phân phối tải load giữa chúng.</p>
<p><strong>Cách mà mỗi cache replica được cập nhật?</strong> Bất cứ khi nào cache miss, servers sẽ hitting vào backend database. Bất cứ khi nào việc này xảy ra, ta có thể cập nhật cache và chuyển tiếp dữ liệu mới vào tất cả các cache replicas. Mỗi replica có thể cập nhật cache của nó bằng cách thêm vào dữ liệu mới. Nếu 1 replica đã có dữ liệu này, thì nó có thể đơn giản từ chỗi cập nhật.</p>
<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden>
<iframe src=https://www.youtube-nocookie.com/embed/6l_tATR7q_0 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="Request flow for accessing a shortened URL"></iframe>
</div>
<h2 id=9-cân-bằng-tải-load-balancer-lb>9. Cân bằng tải Load Balancer (LB)<a hidden class=anchor aria-hidden=true href=#9-cân-bằng-tải-load-balancer-lb>#</a></h2>
<p>Ta có thể thêm 1 lớp cân bằng tải Load balancing layer vào 3 vị trí sau trong hệ thống:</p>
<ol>
<li>Giữa Clients và Application servers.</li>
<li>Giữa Application Servers và database servers.</li>
<li>Giữa Application Servers và Cache servers.</li>
</ol>
<p>Đầu tiên, ta có thể sử dụng cách tiếp cận Round Robin đơn giản để phân phối các incoming requests cân bằng giữa các backend servers. Đây là cách cân bằng tải LB đơn giản để thực thi. 1 ưu điểm khác của cách tiếp cận này là nếu 1 server chết thì LB sẽ loại bỏ nó ra khoản nhóm vòng xoay và sẽ ngừng gửi traffic tới nó.</p>
<p>1 vấn đề phát sinh với Round Robin LB là nó không quan tâm tới tải server load. Do vậy, nếu 1 server bị quá tải hay bị chậm thì LB sẽ không ngừng gửi request mới tới server đó. Để khắc phục vấn đề này, 1 giải pháp LB thông minh hơn có thể được áp dụng là LB sẽ định kỳ truy vấn về tải của backend server và điểu chỉnh traffic dựa vào đó.</p>
<h2 id=10-thanh-lọc-và-dọn-dẹp-db>10. Thanh lọc và dọn dẹp DB<a hidden class=anchor aria-hidden=true href=#10-thanh-lọc-và-dọn-dẹp-db>#</a></h2>
<p>Các dữ liệu có nên tồn tại mãi mãi hay nên được thanh lọc? Nếu thời gian hết hạn do user định nghĩa đã đến thì điều gì cần nên làm với các link hết hạn này?</p>
<p>Nếu ta chọn cách liên tục tìm kiếm các links đã hết hạn để xóa chúng, thì nó gây sức ép lớn đến database. Thay vào đó, ta có thể chậm rãi xóa bỏ các links cũ đã hết hạn này bằng cách dọn dẹp kiểu lazy cleanup. Service của chúng ta cũng cần chắc chắn với các links hết hạn thì sẽ được xóa dù 1 vài links đã hết hạn vẫn sống lâu hơn nhưng nó sẽ không bao giờ được trả về cho users.</p>
<ul>
<li>Bất cứ khi nào user thử truy cập vào 1 link hết hạn, ta có thể xóa link này và trả về lỗi cho user.</li>
<li>1 Cleanup service độc lập sẽ chạy định kỳ để xóa các links đã hết hạn ra khỏi storage và cache. Service này sẽ rất nhẹ và được lập lịch chạy vào thời điểm mà user traffice thấp.</li>
<li>Ta luôn có 1 ngưỡng thời gian hết hạn cho từng link (ví dụ: 2 năm).</li>
<li>Sau khi xóa 1 link đã hết hạn, ta có thể lưu lại key trở lại key-DB để tái sử dụng lại.</li>
<li>Ta cũng nên xoá các links mà không được truy cập sau 1 khoảng thời gian, ví dụ như 6 tháng? Đây có thể là 1 mẹo. Do lưu trữ storage tương đối rẻ, ta cũng có thể quyết định lưu trữ links mãi mãi.</li>
</ul>
<p><img loading=lazy src=/grokking-system-design-interviews/6116923725578240.svg alt="Detailed component design for URL shortening" title="Detailed component design for URL shortening">
</p>
<h2 id=11-telemetry>11. Telemetry<a hidden class=anchor aria-hidden=true href=#11-telemetry>#</a></h2>
<p>Có tổng số bao nhiêu lần 1 short URL được sử dụng, hay user truy cập chúng từ đâu? Cách mà ta sẽ lưu trữ các thống kê này? Nếu mỗi lần có 1 view mới ta lại thực hiện cập nhật 1 DB row, thì điều gì sẽ xảy ra khi 1 URL phổ biến có 1 lượng lớn các concurrent requests?</p>
<p>Một vài thống kê khác cũng đáng để theo dõi: quốc gia của các visitor, thời điểm của các truy cập, các web page tham chiếu tới, browser, hay platform của các visitor.</p>
<h2 id=12-bảo-mật-và-quyền-hạn-security-và-permissions>12. Bảo mật và quyền hạn Security và Permissions<a hidden class=anchor aria-hidden=true href=#12-bảo-mật-và-quyền-hạn-security-và-permissions>#</a></h2>
<p>Users có thể tạo ra các private URLs hay cho phép 1 tập các users cụ thể nào đó được phép truy cập URL?</p>
<p>Chúng ta có thể lưu trữ mức quyền hạn permission level (public/private) với từng URL trong database. Ta có thể tạo ra 1 bảng table riêng để lưu trữ các UserIDs có quyền truy cập 1 URL cụ thể. Nếu 1 user không có quyền hay cố gắng truy cập vào 1 URL, ta có thể gửi 1 lỗi (HTTP 401). Như đã trình bày ở trên, chúng ta đang lưu trữ dữ liệu trong NoSQL wide-column database như Cassandra, khóa key cho table lưu trữ quyền hạn permissions sẽ là &lsquo;Hash&rsquo; hay chuỗi do KGS sinh ra. Cột này sẽ lưu trữ giá trị của các UserIDs được phép truy cập URL.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://lifesucks.dev/tags/system-design-interviews/>system design interviews</a></li>
<li><a href=https://lifesucks.dev/tags/design-url-shortening-service/>Design URL Shortening service</a></li>
<li><a href=https://lifesucks.dev/tags/design-tinyurl/>Design TinyURL</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/>
<span class=title>« Prev Page</span>
<br>
<span>Bài 1: Các bước để trả lời được phỏng vấn System Design Interviews</span>
</a>
<a class=next href=https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/>
<span class=title>Next Page »</span>
<br>
<span>Bài 4: Cách thiết kế Instagram</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on twitter" href="https://twitter.com/intent/tweet/?text=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f&hashtags=systemdesigninterviews%2cDesignURLShorteningservice%2cDesignTinyURL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f&title=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL&summary=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL&source=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f&title=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on whatsapp" href="https://api.whatsapp.com/send?text=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL%20-%20https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL on telegram" href="https://telegram.me/share/url?text=B%c3%a0i%202%3a%20C%c3%a1ch%20thi%e1%ba%bft%20k%e1%ba%bf%201%20d%e1%bb%8bch%20v%e1%bb%a5%20URL%20Shortening%20service%20gi%e1%bb%91ng%20nh%c6%b0%20TinyURL&url=https%3a%2f%2flifesucks.dev%2fposts%2fgrokking-system-design-interviews%2fdesigning-a-url-shortening-service-like-tinyurl%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://lifesucks.dev/>LifeSucks</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>