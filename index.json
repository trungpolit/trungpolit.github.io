[{"content":"Intro  We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read. You can find any YML to TOML converters if necessary.   Guide Follow Quick Start guide to setup hugo and create a new site.\n Note: Use -f to select yml format\nhugo new site \u0026lt;name of site\u0026gt; -f yml\n Make sure you install latest version of hugo(\u0026gt;=0.82.0).\nAfter you have created a new site, at Step 3 follow the steps:\nMethod 1 Inside the folder of your Hugo site, run:\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 Note: You may use  --branch v5.0 to end of above command if you want to stick to specific release.\n Updating theme :\ncd themes/PaperMod git pull  Method 2 you can use as submodule with\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) Note: You may use  --branch v5.0 to end of above command if you want to stick to specific release.\n Updating theme :\ngit submodule update --remote --merge  Method 3 Or you can Download as Zip from Github Page and extract in your themes directory\nDirect Links:\n Master Branch (Latest) v5.0 v4.0 v3.0 v2.0 v1.0  Finally \u0026hellip; Add in config.yml:\ntheme: \u0026#34;PaperMod\u0026#34;  Quick Links   Papermod - Features   Papermod - FAQs   Papermod - Variables   Papermod - Icons   ChangeLog    Sample config.yml  Example Site Structure is present here: exampleSite\n Use appropriately\nbaseURL: \u0026#34;https://examplesite.com/\u0026#34; title: ExampleSite paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \u0026#34;ExampleSite description\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: twitter url: \u0026#34;https://twitter.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai  Sample Page.md --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- You can use it by creating archetypes/post.md\nhugo new --kind post \u0026lt;name\u0026gt;  ","permalink":"https://lifesucks.dev/posts/papermod/papermod-installation/","summary":"Read Install and Update instructions here","title":"Installation | Update"},{"content":"Intro   We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read.\n  You can find any YML to TOML converters if necessary.\n   Assets (js/css) The following is enabled by default\n minification - makes the assets size smallest as possible. bundling - bundles all the styles in one single asset fingerprint/integrity check.   Default Theme light/dark/auto params: # defaultTheme: light # defaultTheme: dark defaultTheme: auto # to switch between dark or light according to browser theme   Theme Switch Toggle (enabled by default) Shows icon besides title of page to change theme\nTo disable it :\ndisableThemeToggle: true You can refer following table for better understanding\u0026hellip;\n   defaultTheme disableThemeToggle checks local storage? checks system theme? Info     auto true No Yes only system theme    false Yes (if not-\u0026gt;2) Yes (2) switch present   dark true No No force dark only    false Yes No switch present   light true No No force light only    false Yes No switch present     Archives Layout Create a page with archive.md in content directory with following content\n. ├── config.yml ├── content/ │ ├── archives.md \u0026lt;--- Create archive.md here │ └── posts/ ├── static/ └── themes/ └── PaperMod/ and add the following to it\n--- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- Note: Archives Layout does not support Multilingual Month Translations.\nex: archives.md\n Regular Mode (default-mode)  Home-Info Mode Use 1st entry as some Information\nadd following to config file\nparams: homeInfoParams: Title: Hi there wave Content: Can be Info, links, about... socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; ex. config.yml#L106\n Profile Mode Shows Index/Home page as Full Page with Social Links and Image\nadd following to config file\nparams: profileMode: enabled: true title: \u0026#34;\u0026lt;Title\u0026gt;\u0026#34; # optional default will be site title subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;image link\u0026gt;\u0026#34; # optional imageTitle: \u0026#34;\u0026lt;title of image as alt\u0026gt;\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34;  Search Page PaperMod uses Fuse.js Basic for seach functionality\nAdd the following to site config, config.yml\noutputs: home: - HTML - RSS - JSON # is necessary Create a page with search.md in content directory with following content\n--- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; --- To hide a particular page from being searched, add it in post\u0026rsquo;s fron\u0026rsquo;t matter\n--- searchHidden: true ex: search.md\n Search Page also has Key bindings:\n Arrow keys to move up/down the list Enter key (return) or Right Arrow key to Go to highlighted page Escape key to clear searchbox and results   For Multilingual use search.\u0026lt;lang\u0026gt;.md ex. search.es.md.\nNote: Search will work only on current language, user is currently on !\nCustomizing Fusejs Options\nRefer https://fusejs.io/api/options.html for Options, Add those as shown below.\nparams: fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;]  Draft Page indication adds [draft] mark to indicate draft pages.\n Post Cover Image In post\u0026rsquo;s page-variables add :\ncover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # can also paste direct link from external site # ex. https://i.ibb.co/K0HVPBd/paper-mod-profilemode.png alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; relative: false # To use relative path for cover image, used in hugo Page-bundles When you include images in the Page Bundle, multiple sizes of the image will automatically be provided using the HTML5 srcset field.\nTo reduce generation time and size of the site, you can disable this feature using\nparams: cover: responsiveImages: false To enable hyperlinks to the full image size on post pages, use\nparams: cover: linkFullImages: true  Share Buttons on post Displays Share Buttons at Bottom of each post\nto show share buttons add\nparams: ShowShareButtons: true  Show post reading time Displays Reading Time (the estimated time, in minutes, it takes to read the content.)\nTo show reading time add\nParams: ShowReadingTime: true  Show Table of Contents (Toc) on blog post Displays ToC on blog-pages\nTo show ToC add following to page-variables\nShowToc: true To keep Toc Open by default on a post add following to page-variables:\nTocOpen: true  BreadCrumb Navigation Adds BreadCrumb Navigation above Post\u0026rsquo;s Title to show subsections and Navigation to Home\nparams: ShowBreadCrumbs: true Can be diabled for particular page\u0026rsquo;s front-matter\n--- ShowBreadCrumbs: false ---  Edit Link for Posts Add a button to suggest changes by using the file path of the post to link to a edit destination.\nFor site config use:\nParams: editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Can be modified for individual pages\n--- editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- The example above would yield the following link for the post file posts/post-name.md: https://github.com/\u0026lt;path_to_repo\u0026gt;/content/posts/post-name.md\n   Parameter Required Default Value     editPost.URL true -   editPost.appendFilePath false false   editPost.Text false \u0026ldquo;Edit\u0026rdquo;    Since the link generated is a regular HTML anchor tag \u0026lt;a href=...\u0026gt;, you can also use other URL schemas like mailto://, e.g. URL: \u0026quot;mailto://mail@example.com?subject=Suggesting changes for \u0026quot;\n Other Posts suggestion below a post Adds a Previous / Next post suggestion under a single post\nparams: ShowPostNavLinks: true  Multiple Authors To Use multiple authors for a post, in post-variables:\n--- author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] --- To use Multiple Authors Site-wide, in config.yml:\nparams: author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;]  Comments to add comments, create a html file\nlayouts/partials/comments.html\nand paste code provided by your comments provider\nalso in config add this\nparams: comments: true read more about this hugo-comments\n AccessKeys c - ToC Open/Close g - Go To Top h - Home (according to current lang) t - Theme toggle / - Jumps to search page if in menu What\u0026rsquo;s AccessKeys ?\n Enhanced SEO Enabled only when env: production\n Rich Results/Snippets Support  Twitter Cards Support  The Twitter Cards metadata, except twitter:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The twitter:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. images: - image_01.png - image_02.png  Finally, if neither of those are provided, twitter:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name.  OpenGraph support  The OpenGraph metadata, except og:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The og:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. images: - image_01.png - image_02.png  Finally, if neither of those are provided, og:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name. For pages, you can also add audio (using frontmatter audio: filename.ext) and/or videos. videos: - filename01.mov - filename02.avi    Multilingual Support  Misc Scroll-Bar themed (by default) Smooth Scroll between in-page links (by default) Scroll-to-Top Button (by default) Displays a Scroll-to-Top button in right-bottom corner Google Analytics integration Syntax highlighting RSS feeds ","permalink":"https://lifesucks.dev/posts/papermod/papermod-features/","summary":"Learn About All Features in PaperMod","title":"Features"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://lifesucks.dev/posts/markdown-syntax.fr/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide For L2"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://lifesucks.dev/posts/markdown-syntax.fa/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide For RTL"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Gist  List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://lifesucks.dev/posts/markdown-syntax/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode    Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019  Vimeo Simple Shortcode  .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  ","permalink":"https://lifesucks.dev/posts/rich-content/","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\n  Examples  Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"https://lifesucks.dev/posts/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  .emojify { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; font-size: 2rem; vertical-align: middle; } @media screen and (max-width:650px) { .nowrap { display: block; margin: 25px 0; } } ","permalink":"https://lifesucks.dev/posts/emoji-support/","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","title":"Emoji Support"},{"content":"1. Facebook newsfeed là gì? 1 Newsfeed là 1 danh sách các bài stories được cập nhật liên tục nằm chính giữa trang Facebook’s homepage. Nó bao gồm các cập nhật liên quan tới trạng thái status, photos, videos, links, app activity hay các likes từ những người, trang pages, hay groups mà người dùng user theo dõi follow trên Facebook.\nVới bất cứ hệ thống mạng xã hội nào mà bạn thiết kế như Twitter, Instagram, hay Facebook thì bạn sẽ cần 1 hệ thống kiểu Newsfeed để hiện thị các thông tin cập nhật từ những người bạn và những người mà bạn theo dõi.\n2. Yêu cầu Requirements và mục tiêu Goals của hệ thống Chúng ta sẽ thiết kế 1 hệ thống newsfeed cho Facebook theo các yêu cầu sau: Yêu cầu về mặt tính năng:\n Newsfeed cần được tạo ra dựa trên các bài posts từ những người, trang pages, groups mà người dùng user theo dõi follow. 1 người dùng user có thể có rất nhiều bạn và theo dõi follow 1 lượng lớn các pages/groups. Feeds có thể chứ images, videos, hay chỉ chứa text. Hệ thống của chúng ta cần hỗ trợ thêm mới các bài posts mới nhanh nhất có thể khi chúng vừa mới xuất hiện cho tất cả các users đang hoạt động.  Yêu cầu không liên quan tới tính năng:\n Hệ thống có khả năng tạo ra newsfeed cho bất cứ user nào 1 cách real-time và độ trễ tối đa là 2s. 1 bài post không cần tới 5s để nó xuất hiện trong feed của 1 user giả định là bài post vừa được đăng.  3. Ước lượng trữ lượng và các ràng buộc Ta giả định 1 user trung bình sẽ có 300 bạn và theo dõi 200 pages.\nƯớc lượng về traffic: Giả sử ta có 300M người dùng hoạt động hàng ngày và trung bình mỗi người dùng sẽ làm mới timeline của họ 5 lần 1 ngày. Kết quả là sẽ có 1.5B newsfeed request 1 ngày và xấp xỉ 17,500 request mỗi giây.\nƯớc lượng về storage: Ở mức trung bình, ta giả định chúng ta có khoảng 500 posts trên mọi newsfeed của mỗi user và chúng ta sẽ giữ chúng trong bộ nhớ memory để lấy chúng ra 1 cách nhanh nhất. Chúng ta cũng giả định rằng trung bình mỗi bài post có kích thước khoảng 1KB. Điều này có nghĩa rằng chúng ta cần lưu trữ khoảng 500KB dữ liệu data trên mỗi user. Để lưu trữ được tất cả data cho tất cả các users đang active chúng ta cần 150TB memory. Nếu 1 server có thể đáp ứng được 100GB thì chúng ta cần khoảng 1500 servers để giữ được 500 bài posts mới nhất trong memory cho tất cả các users đang active.\n4. System APIs  Khi ta đã chốt được các yêu cầu requirements, thì ý tưởng tốt là định nghĩa các system APIs. Điều này sẽ phản ánh đúng những gì mà hệ thống kì vọng.\n Chúng ta cần có SOAP hay REST APIs để expose ra các tính năng của các service. Đoạn ví dụ dưới dùng để định nghĩa API dùng để lấy ra newsfeed:\ngetUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies) Các tham số:\n api_dev_key (string): Api developer key cần phải được đăng ký để sử dụng và dùng để throttle users dựa trên hạn mức quota mà họ được cấp. user_id (number): ID của user mà hệ thống dùng để tạo newsfeed. since_id (number): Không bắt buộc, trả về kết quả với 1 ID cao hơn (mới hơn) ID cho trước. count (number): Không bắt buộc, định nghĩa số lượng các feed items cần lấy ra, giới hạn max là 200. max_id (number): Không bắt buộc, trả về kết quả với 1 ID nhỏ hơn hoặc bằng (cũ hơn) ID cho trước. exclude_replies(boolean): Không bắt buộc, Tham số này sẽ ngăn chặn việc trả về các replies xuất hiện trong kết quả timeline được trả về.  Kết quả trả về: (JSON) trả về 1 JSON object chứa 1 danh sách các feed items.\n5. Database Design Ta sẽ có 3 đối tượng objects chính: User, Entity (e.g. page, group, etc.), and FeedItem (or Post). Dưới đây là 1 vài quan sát về quan hệ relationships giữa các đối tượng này:\n 1 user có thể follow các đối tượng entities khác và có thể là bạn với users khác. Cả users và các đối tượng entities có thể post FeedItems chứa text, images hay videos. Mỗi FeedItem sẽ có 1 UserID dùng để xác định User tạo ra nó. Cho đơn giản, ta giả định chỉ có users mới tạo được feed items mặc dù Facebook Pages cũng có thể tạo ra. Mỗi FeedItem có thể có 1 EntityID dùng để trỏ tới trang page hay group mà bài posts được tạo ra.  Nếu ta đang sử dụng 1 relational database, chúng ta sẽ cần mô hình hóa 2 mối quan hệ relations: User-Entity relation và FeedItem-Media relation. Do mỗi user có thể là bạn với nhiều người khác và theo dõi follow rất nhiều đối tượng entities, ta có thể lưu trữ mối quan hệ relation ra thành bảng table riêng. cột \u0026ldquo;Type\u0026rdquo; trong bảng \u0026ldquo;UserFollow\u0026rdquo; dùng để xác định đối tượng entity đang được follow là 1 User hay Entity. Tương tự ta cũng cần có 1 bảng table cho FeedMedia relation.\n6. High Level System Design Ở mức high level, vấn đề của chúng ta chia làm 2 phần:\nFeed generation: Newsfeed được tạo từ các bài posts (hay feed items) từ những users hay entities (pages hay groups) mà 1 user theo dõi. Do đó, bất cứ khi nào hệ thống nhận được yêu cầu tạo feed cho 1 user (ví dụ là Jane), thì chúng ta sẽ thực hiện các bước sau:\n Lấy về IDs của tất cả các users và entities mà Jane theo dõi. Lấy về các bài posts mới nhất, phổ biến nhất, phù hợp nhất cho những IDs này. Đây là posts tiềm năng mà ta có thể hiện thị chúng trong newsfeed của Jane. Đánh giá các bài posts này dựa trên sự phù hợp với Jane. Điều này phản ánh trực tiếp với feed của Jane hiện tại. Lưu trữ feed này vào trong cache và trả về top các bài posts (tầm 20) để hiện thị trong Jane feed. Ở phía front-end, khi Jane chạm tới cuối feed hiện tại của cô ấy, thì cô ấy có thể lấy về tiếp 20 posts tiếp theo từ server và cứ tiếp tục như vậy.  Feed publishing: Bất cứ khi nào Jane load trang newsfeed page của cô ấy, cô ấy phải thực hiện request và pull các feed items từ server. Bất cứ khi nào cô ấy chạm vào đáy của feed hiện tại, thì cô ấy có thể pull data mới từ server. Với những phần tử items mới hơn thì server có thể thông báo cho Jane và cô ấy có thể pull hay server có thể push những posts mới này xuống. Chúng ta sẽ bàn về các lựa chọn này sau.\nỞ mức high level, chúng ta chỉ cần các components sau trong Newsfeed service:\n Web servers: Cần duy trì 1 connection với user. Connection này có thể được sử dụng để chuyển dữ liệu data giữa user và server. Application server: Thực hiện xử lý các luồng nghiệp vụ workflows dùng để lưu trữ các posts mới trong database servers. Chúng ta sẽ cần 1 vài application servers để lấy về và để push newsfeed xuống end user. Metadata database and cache: Dùng để lưu trữ các thông tin metadata liên quan tới Users, Pages, Groups. Posts database and cache: Dùng để lưu trữ các thông tin metadata liên quan tới posts và các nội dung contents của họ. Video and photo storage, and cache: Dạng blob storage, dùng để lưu trữ tất cả các media có trong bài posts. Newsfeed generation service: Dùng để thu thập và xếp hạng tất cả các posts phù hợp với 1 user để tạo ra newsfeed và lưu nó trong cache. Service này cũng sẽ nhận các cập nhật mới nhất và sẽ thêm các feed items mới này vào timeline của user bất kỳ. Feed notification service: Thông báo cho user các feed items mới đang có sẵn cho newsfeed của họ.  Dưới đây là biểu đồ kiến trúc ở mức high-level, User B và User C đang theo dõi User A.\n7. Detailed Component Design Ta sẽ bàn chi tiết về 2 components khác nhau.\na. Feed generation Giờ ta xét 1 ví dụ đơn giản là newsfeed generation service sẽ lấy về các posts mới nhất từ tất cả các users và entities mà Jane theo dõi; câu truy vấn sẽ giống như sau:\n(SELECT FeedItemID FROM FeedItem WHERE UserID in ( SELECT EntityOrFriendID FROM UserFollow WHERE UserID = \u0026lt;current_user_id\u0026gt; and type = 0(user)) ) UNION (SELECT FeedItemID FROM FeedItem WHERE EntityID in ( SELECT EntityOrFriendID FROM UserFollow WHERE UserID = \u0026lt;current_user_id\u0026gt; and type = 1(entity)) ) ORDER BY CreationDate DESC LIMIT 100 Các issues xảy ra với cách thiết kế này dành cho newsfeed generation service:\n Sẽ rất chậm đối với các users có nhiều bạn friends hay người theo dõi follows do ta phải thực hiện sorting/merging/ranking trên 1 lượng lớn các posts. Chúng ta tạo ra timeline khi 1 user thực hiện load trang page của họ. Điều này sẽ rất chậm và có độ trễ cao. Với những live updates, mỗi status update sẽ được cập nhật vào trong các feed updates của tất cả các followers. Điều này gây ra sự tồn đọng high backlogs trong Newsfeed Generation Service. Với những live updates, server push (hay thông báo) các posts mới tới những users có thể gây ra vấn đề nặng tải, đặc biệt là đối với những người, hay pages có lượng lớn followers. Để cải thiện hiệu năng, ta có thể tạo trước timeline và lưu nó trong 1 memory.  Offline generation for newsfeed: Chúng ta cần có các servers dành riêng cho việc liên tục tạo ra các newsfeed của users và lưu trữ chúng trong memory. Do đó bất cứ khi nào 1 user request lấy về các posts mới cho feed của họ, chúng ta có thể đơn giản lấy các feed này từ nơi lưu trữ đã tạo trước. Bằng cách sử dụng cơ chế này, thì newsfeed của user không cần phải tạo khi có yêu cầu, và do đó có thể trả về cho users bất cứ khi nào có yêu cầu.\nBất cứ khi các servers này cần tạo feed cho 1 user, chúng sẽ truy vấn để lấy về thời điểm tạo feed gần nhất được tạo với user này đầu tiên. Sau đó, các feed data mới sẽ được tạo từ thời điểm tạo này trở về sau. Chúng ta có thể lưu trữ thông tin data này trong 1 hash table, với key là UserID và value là 1 cấu trúc STRUCT giống như sau:\nStruct { LinkedHashMap\u0026lt;FeedItemID, FeedItem\u0026gt; feedItems; DateTime lastGenerated; } Chúng ta có thể lưu trữ FeedItemIDs trong 1 cấu trúc data structure giống như Linked HashMap hay TreeMap, chúng có thể cho phép ta không chỉ nhảy tới bất cứ feed item nào mà còn có thể lặp qua chúng thông qua map 1 cách dễ dàng. Bất cứ khi nào users muốn lấy về nhiều feed items hơn, chúng ta có thể gửi last FeedItemID mà họ đang nhìn thấy trong newsfeed của họ, và sau đó ta có thể nhảy tới FeedItemID đó trong hash-map và trả về batch/page của feed items tiếp theo từ đó.\nBao nhiêu feed items mà ta nên lưu trữ trong memory cho feed của 1 user? Thời điểm khởi đầu, chúng ta có thể quyết định lưu 500 feed items cho mỗi user, nhưng con số này có thể được điều chỉnh sau đó dựa trên mức sử dụng. Ví dụ, nếu ta giả định 1 page của 1 user feed sẽ có 20 bài posts và đa số users không bao giờ duyệt trên 10 pages feed của họ, chúng ta có thể quyết định chỉ lưu trữ 200 posts trên mỗi user. Với bất cứ user người mà muốn xem nhiều bài posts hơn (nhiều hơn những gì lưu trong memory), chúng ta có thể truy vấn chúng từ backend servers.\nChúng ta nên tạo (hay giữ trong memory) newsfeed cho tất cả users? Có rất nhiều users không đăng nhập 1 cách thường xuyên. Đây là 1 vài thứ mà ta có thể làm để xử lý điều này; 1) 1 cách tiếp cận hiển nhiên nhất là sử dụng 1 LRU cache để xóa users khỏi memory do họ không truy cập newsfeed của họ trong 1 khoảng thời gian dài. 2) 1 cách tiếp cận thông minh hơn là tìm ra kiểu đăng nhập của users để tạo ra các newsfeed của họ trước, ví dụ thời điểm nào trong ngày 1 user hoạt động và những ngày nào trong tuần mà user có thể truy cập newsfeed của họ?\n","permalink":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-facebooks-newsfeed/","summary":"1. Facebook newsfeed là gì? 1 Newsfeed là 1 danh sách các bài stories được cập nhật liên tục nằm chính giữa trang Facebook’s homepage. Nó bao gồm các cập nhật liên quan tới trạng thái status, photos, videos, links, app activity hay các likes từ những người, trang pages, hay groups mà người dùng user theo dõi follow trên Facebook.\nVới bất cứ hệ thống mạng xã hội nào mà bạn thiết kế như Twitter, Instagram, hay Facebook thì bạn sẽ cần 1 hệ thống kiểu Newsfeed để hiện thị các thông tin cập nhật từ những người bạn và những người mà bạn theo dõi.","title":"Bài 13: Cách thiết kế  Facebook Newsfeed"},{"content":"Rất nhiều kỹ sư phần mềm cảm thấy quá sức trong các cuộc phỏng vấn system design interviews (SDIs) bởi vì 3 lys do chính sau:\n Do các câu hỏi thường không có cấu trúc chặt chễ trong các buổi phỏng vấn SDIs, các câu hỏi này đa phần là hỏi về giải pháp thiết kế để giải quyết các vấn đề từ đầu tới cuối và thường không bó hẹp bởi 1 câu trả lời đúng. Việc thiếu kinh nghiệm của chính bản thân họ trong việc phát triển xây dựng hệ thống large scale systems. Họ thường thiếu chuẩn bị cho các cuộc phỏng vấn SDIs.  Không giống như các cuộc phỏng vấn coding interviews, các ứng viên thường không có chủ định chuẩn bị cho các cuộc phỏng vấn SDIs, đa số họ thường xử lý không tốt trong các cuộc phỏng vấn này, đặc biệt ở các công ty như Google, Facebook, Amazon, Microsoft, etc. Ở những công ty này, các ứng viên thường xử lý dưới mức trung bình để đạt được cơ hội hiếm có, là nhận được 1 offer như mong đợi. Ngược lại, những ứng viên xử lý tốt trong cuộc phỏng vấn, sẽ luôn nhận được kết qủa tốt với mức offer tốt hơn (vị trí và mức thu nhập cao hơn) do cuộc phỏng vấn sẽ chỉ ra khả năng của ứng viên trong việc xây dựng 1 hệ thống phức tạp.\nTrong bài học này, chúng ta sẽ tuân theo các bước tiếp cận sau để giải quyết các vấn đề về thiết kế. Bước đầu tiên, ta cần đi qua các bước sau:\nBước 1: làm rõ các yêu cầu Requirements Luôn là 1 ý tưởng tốt khi ta đặt câu hỏi về chính xác phạm vi scope của vấn đề mà ta đang giải quyết. Các câu hỏi về thiết kế thường là các câu hỏi giải quyết 1 vấn đề từ đầu tới cuối, và chúng thường không chỉ có 1 câu trả lời đúng. Đây là lý do tại sao việc cần làm rõ các yêu cầu mơ hồ từ sớm trong buổi phỏng vấn, là điều hết sức quan trọng. Các ứng viên nên dành đủ thời gian để định nghĩa ra mục tiêu cuối của hệ thống, sẽ có cơ hội tố t hơn để thành công trong cuộc phỏng vấn. Do chúng ta chỉ có tầm 35-40 phút để thiết kế 1 hệ thống large system, nên chúng ta phải làm rõ những thành phần cấu thành nên hệ thống mà ta đang tập trung vào thiết kế.\nChúng ta sẽ đi sâu vào vấn đề này với 1 ví dụ cụ thể là thiết kế 1 Twitter-like service. Đây là 1 vài câu hỏi dành cho việc thiết kế Twitter cần được trả lời trước khi ta chuyển sang bước tiếp theo:\n Người dùng users của service có khả năng post tweets và theo dõi follow những người khác? Hệ thống có tạo và hiện thị ra timeline của user? Tweets có chứa photos và videos? Chỉ tập trung thiết kế backend, có cần thiết kế front-end? Người dùng users có thể tìm kiếm tweets? Hệ thống có hiện thị ra các hot trending topics? Có tính năng push notification cho các tweets mới hay là quan trọng?  Tất cả câu hỏi này sẽ định hình các ta thiết kế hệ thống.\nBước 2: Ước lượng/định lượng hệ thống Cũng luôn là 1 ý tưởng tốt là việc định lượng tính mở rộng của hệ thống mà chúng ta đang thiết kế. Điều này sẽ giúp chúng ta tập chung vào việc mở rộng scaling, phân tán partitioning, cân bằng tải load balancing, caching:\n Tính mở rộng mà hệ thống kỳ vọng (ví dụ: số lượng các new tweets, số lượt view tweet views, số lượng tạo timeline generations trên mỗi giây)? Số lượng lưu trữ storage mà hệ thống cần? Chúng ta có các yêu cầu về lưu trữ storage requirements khác nhau nếu người dùng users có thể có photos và videos trong tweets của họ. Lưu lượng băng thông network bandwidth mà hệ thống kỳ vọng? Đây sẽ là điểm quan trọng trong việc ta quyết định quản lý traffic và cân bằng tải balance load giữa các servers.  Bước 3: Các định nghĩa System interface definition Định nghĩa những APIs sẽ có trong hệ thống. Điều này sẽ xác lập ra chính xác các chức năng hệ thống và đảm bảo rằng chúng ta không làm sai bất kỳ yêu cầu nào của hệ thống. 1 vài ví dụ về APIs dành cho Twitter-like service như sau:\npostTweet(user_id, tweet_data, tweet_location, user_location, timestamp, …) generateTimeline(user_id, current_time, user_location, …) markTweetFavorite(user_id, tweet_id, timestamp, …) Bước 4: Định nghĩa data model Việc định nghĩa data model cũng thuộc các bước đầu tiên trong cuộc phỏng vấn, cũng cần làm rõ các luồng data flow giữa các thành phần khác nhau của hệ thống. Sau khi làm rõ bước này, thì điều này sẽ định hướng cho ta cách quản lý và phân vùng dữ liệu. Các ứng viên nên định nghĩa rõ ra các thành phần hệ thống khác nhau, cách chúng tương tác với thành phần khác, và các khía cạnh khác nhau của việc quản lý dữ liệu như lưu trữ storage, luân chuyển transportation, mã hóa encryption. Đây là 1 vài thành phần khác nhau dành cho Twitter-like service:\n User: UserID, Name, Email, DoB, CreationDate, LastLogin, etc. Tweet: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc. UserFollow: UserID1, UserID2 FavoriteTweets: UserID, TweetID, TimeStamp  Loại database nào mà chúng ta nên sử dụng? Có phải NoSQL như Cassandra phù hợp với yêu cầu mà ta cần, hay ta sử dụng 1 giải pháp dựa trên MYSQL? Loại lưu trữ block storage nào mà ta nên sử dụng để lưu trữ photos và videos?\nBước 5: High-level design Thực hiện vẽ ra các biểu đồ diagram để biểu diễn ra các thành phần core của hệ thống. Chúng ta nên xác định đủ các thành phần components cần có để giải quyết các vấn đề thực sự end to end.\nĐối với Twitter, ở mức high level, ta sẽ cần nhiều application servers để phục vụ các read/write requests với cân bằng tải load balancers ở trước chúng để phân phối traffic. Giả sử rằng chúng ta sẽ có nhiều read traffic hơn so với write, ta có thể quyết định phân tách servers riêng rẽ xử lý trong ngữ cảnh này. Ở phía back-end, ta cần có 1 database hiệu quả có thể lưu trữ toàn bộ tweets và hỗ trợ được lượng lớn large number of reads. Ta cũng sẽ cần 1 hệ thống lưu trữ file phân tán distributed file storage system cho việc lưu trữ photos và videos.\nBước 6: Detailed design Phân tích sâu hơn vào 2 hay 3 thành phần chính của hệ thống; Dựa vào phản hồi của người phỏng vấn, họ sẽ chỉ rõ cho ta những thành phần nào cần thảo luận thêm. Chúng ta nên trình bày các hướng tiếp cận khác nhau, đưa ra ưu và nhược điểm của chúng, và giải thích tại sao ta lại lựa chọn cách tiếp cận này hơn cái khác. Nhớ rằng, không có 1 câu trả lời đúng duy nhất, luôn có 1 thứ quan trọng phải xét đến là sự cân bằng tradeoffs giữa các lựa chọn khác nhau dựa trên các ràng buộc của hệ thống:\n Do chúng ta sẽ lưu trữ 1 lượng lớn dữ liệu, nên ta sẽ thực hiện phân tán dữ liệu phân tán ra nhiều databases? ta nên lưu trữ toàn bộ dữ liệu của 1 user trên cùng 1 database? Vấn đề issue gì có thể xảy ra? Cách ta xử lý những hot users khi họ tweet rất nhiều hay follow rất nhiều người khác? Do timeline của user sẽ chứa các tweets gần đây, ta có nên thử lưu trữ dữ liệu này để tối ưu hóa cho việc truy vấn lấy ra latest tweets? Bao nhiêu và những layer nào mà chúng ta dùng để cache để tăng tốc? Những components nào cần được load balancing?  Bước 7: Cách xác định và giải quyết các nút cổ chai bottlenecks Thực hiện đề cập tới nhiều các nút cổ chai bottlenecks nhiều nhất có thể và các cách tiếp cận khác nhau để giảm thiểu chúng:\n Hệ thống có tồn tại điểm single point of failure nào không? Chúng ta sẽ làm gì để gỉam thiểu được chúng? Chúng ta có đủ số replicas của dữ liệu và hệ thống vẫn chạy đáp ứng người dùng nếu có 1 vài servers gặp lỗi? Tương tự, chúng ta có đủ số copies của các services khác nhau đang chạy mà 1 vài trong số chúng gặp lỗi thì không gây ra shutdown toàn bộ hệ thống? Cách chúng ta giám sát hiệu năng của các services? Chúng ta đã có những cảnh báo bất cứ khi nào các thành phần quan trọng của hệ thống gặp lỗi hay gặp vấn đề về hiệu năng?  Tổng kết Ngắn gọn, việc chuẩn bị có chủ định khi thực hiện phỏng vấn sẽ là chìa khóa để giúp bạn thành công trong buổi phỏng vấn system design interviews. Các bước ở trên sẽ hướng dẫn bạn đi đúng hướng và bao quát được các cách tiếp cận khác nhau khi thiết kế hệ thống.\n","permalink":"https://lifesucks.dev/posts/grokking-system-design-interviews/system-design-interviews-a-step-by-step-guide/","summary":"Rất nhiều kỹ sư phần mềm cảm thấy quá sức trong các cuộc phỏng vấn system design interviews (SDIs) bởi vì 3 lys do chính sau:\n Do các câu hỏi thường không có cấu trúc chặt chễ trong các buổi phỏng vấn SDIs, các câu hỏi này đa phần là hỏi về giải pháp thiết kế để giải quyết các vấn đề từ đầu tới cuối và thường không bó hẹp bởi 1 câu trả lời đúng.","title":"Bài 1: Các bước để trả lời được phỏng vấn System Design Interviews"},{"content":"1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening? URL shortening được sử dụng để tạo ra các định danh ngắn gọn hơn shorter aliases cho các URLs dài dòng. Chúng ta gọi các định danh được làm ngắn này là các \u0026ldquo;short links.\u0026rdquo;. Các users được điều hướng tới URL gốc khi họ thực hiện truy cập vào các short links này. Các short links sẽ tiết kiệm nhiều không gian khi hiện thị, in ấn, truyền thông điệp hay tweeted. Thêm nữa, các users thường hiếm khi gõ sai khi thực hiện gõ các URLs được làm ngắn gọn lại.\nVí dụ, nếu chúng ta làm ngắn URL sau thông qua TinyURL:\nhttps://www.educative.io/courses/grokking-the-system-design-interview/m2ygV4E81AR Chúng ta sẽ nhận được kết quả:\nhttps://tinyurl.com/rxcsyr3r URL được làm ngắn chỉ bằng 1 phần 3 so với URL gốc. Hệ thống URL shortening được sử dụng để tối ưu links thông qua nhiều thiết bị devices, có thể track được các links cụ thể để phân tích audience, đo lường hiệu quả của chiến dịch quảng cáo, hay dùng để ẩn đi URLs gốc.\nNếu bạn chưa từng sử dụng tinyurl.com trước đây, bạn nên thử tạo ra 1 shortened URL và bỏ thời gian để sử dụng 1 số options khác nhau do dịch vụ cung cấp. Nó sẽ giúp bạn hiểu về chương này.\n2. Yêu cầu và mục tiêu của hệ thống  Bạn phải luôn luôn làm rõ các yêu cầu ngay từ thời điểm bắt đầu của buổi phỏng vấn. Và đảm bảo chắc chắn rằng đặt ra các câu hỏi để tìm ra chính xác phạm vi scope của hệ thống.\n Hệ thống URL shortening system sẽ có các yêu cầu như sau: Các yêu cầu về mặt tính năng:\n Đưa ra 1 URL, dịch vụ của chúng ta sẽ tạo ra 1 định danh ngắn hơn và duy nhất cho nó. Định danh này được gọi là 1 short link. Link này được làm ngắn gọn đủ để dễ dàng khi thực hiện copied và pasted vào trong các ứng dụng applications. Khi users truy cập 1 short link, dịch vụ của chúng ta sẽ điều hướng họ tới link gốc. Các users có thể tùy chọn cấu hình tùy chỉnh custom short link cho URL của họ. Các links sẽ bị hết hạn sau 1 khoảng thời gian. Các users có thể định nghĩa được thời gian hết hạn này.  Các yêu cầu không liên quan tới tính năng:\n Hệ thống phải có tính sẵn sàng cao. Đây là yêu cầu bắt buộc bởi vì khi hệ thống bị down, thì tất cả các chuyển hướng URL sẽ gặp lỗi. Chuyển hướng URL nên xảy ra theo thời gian thực với độ trễ thấp. Các Shortened links nên được tạo ra 1 cách bất định (khó đoán trước).  Các yêu cầu mở rộng:\n Phân tích Analytics, ví dụ 1 url được chuyển hướng bao nhiêu lần? Dịch vụ nên được truy cập được thông qua REST APIs bởi các services khác.  3. Định lượng sức chứa và các ràng buộc Hệ thống của ta sẽ nặng về read. Sẽ có rất nhiều chuyển hướng redirection requests so với các new URL shortenings. Ta giải định tỉ lệ này khoảng 100:1 giữa read và write.\nĐịnh lượng traffic: Giả sử, chúng ta sẽ có 500M new URL shortenings mới mỗi tháng, với tỉ lệ 100:1 read/write, ta kì vọng có 50B (50 tỷ) chuyển hướng redirections với cùng chu kỳ:\n100*500M =\u0026gt; 50B Số lượng truy vấn trên giây Queries Per Second (QPS) là bao nhiêu? New URLs shortenings được làm ngắn trên mỗi giây:\n500 million / (30 days * 24 hours * 3600 seconds) = ~200 URLs/s Xét tới tỉ lệ 100:1 read/write, URLs redirections trên mỗi giây sẽ là:\n100 * 200 URLs/s = 20K/s Định lượng lưu trữ storage: Giả sử ta lưu trữ mọi URL shortening request (bao gồm cả shortened link tương ứng với nó) trong vòng 5 năm. Do ta kỳ vọng có 500M new URLs mỗi tháng, thì tổng số objects mà ta kỳ vọng lưu trữ là 30B (30 tỷ):\n500 million * 5 years * 12 months = 30 billion Ta giả định mỗi object được lưu trữ mất xấp xỉ 500 bytes. Ta sẽ cần 15TB lưu trữ storage:\n30 billion * 500 bytes = 15 TB Định lượng băng thông Bandwidth: Với các write requests, do chúng ta kỳ vọng 200 new URLs trên mỗi giây, tổng số dữ liệu incoming data sẽ khoảng 100KB trên giây:\n200 * 500 bytes = 100 KB/s Với các read requests, do mỗi giây ra kỳ vọng ~ 20K chuyển hướng URLs redirections, tổng số dữ liệu outgoing data sẽ khoảng 10MB trên giây:\n20K * 500 bytes = ~10 MB/s Định lượng memory: Nếu ta muốn cache 1 vài hot URLs mà thường xuyên được truy cập, số lượng memory và ta cần để lưu trữ chúng là bao nhiêu? Nếu ta tuân theo định luật 80-20 rule, có nghĩa là 20% số URLs sẽ tạo ra 80% traffic, Chúng ta sẽ muốn cache lại 20% hot URLs. Do ta có khoảng 20K requests trên giây, ta sẽ có khoảng 1.7B (tỷ) requests mỗi ngày:\n20K * 3600 seconds * 24 hours = ~1.7 billion Ta sẽ cache lại 20% số requests này, ta sẽ cần 170GB memory:\n0.2 * 1.7 billion * 500 bytes = ~170GB 1 điểm nữa ta cần lưu ý ở đây là sẽ có nhiều duplicate requests tới cùng 1 URL, nên số lượng memory mà ta sử dụng sẽ thấp hơn 170GB. Định lượng ở mức High-level: Giả định có 500M new URLs mỗi tháng và tỷ lệ 100:1 read:write, bảng sau đây sẽ chỉ ra định lượng tổng quan của service:\n   Chỉ số Định lượng     New URLS 200/s   URL redirections 20k/s   Incoming data 100KB/s   Outgoing data 10MB/s   Storage for 5 years 15TB   Memory for cache 170GB    4. System APIs  Khi chúng ta đã hoàn thành việc làm rõ yêu cầu, sẽ luôn là 1 ý tưởng tốt để định nghĩa ra các system APIs. Do đây đúng là những gì mà hệ thống kỳ vọng\n Chúng ta có thể tạo ra SOAP hay REST APIs để lộ ra các tính năng của hệ thống. Đoạn mã dưới đây định nghĩa APIs dùng để tạo mới và xóa URLs:\ncreateURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None) Các tham số:\n api_dev_key (string): API developer key của 1 account đã đăng ký. Nó sẽ được sử dụng cho nhiều mục đích khác như việc giới hạn gọi api của users dựa trên quota được cấp. original_url (string): URL gốc được làm ngắn custom_alias (string): custom key tùy chọn cho URL. user_name (string): tùy chọn user name được dùng để mã hóa encoding. expire_date (string): tùy chọn ngày hết hạn cho shortened URL.  Return:(string) Khi việc thêm mới thành công nó sẽ trả về shortened URL; mặt khác nó sẽ trả về 1 mã lỗi error code.\ndeleteURL(api_dev_key, url_key) Với url_key là chuỗi biểu thị shortened URL được trả về; Nếu xóa thành công sẽ trả về \u0026ldquo;URL Removed\u0026rdquo;. Cách mà ta phát hiện và ngăn chặn việc lạm quyền? Để ngăn chặn điều này, ta có thể giới hạn users thông qua api_dev_key. Mỗi api_dev_key có thể bị giới hạn 1 số lượng tạo URL creations hay chuyển hướng redirections trên 1 khoảng thời gian (Điều này có thể được thiết lập các khoảng thời gian khác nhau trên mỗi developer key).\n5. Database Design  Định nghĩa DB schema trong những bước đầu tiên của buổi phỏng vấn sẽ giúp hiểu được về luồng data flow giữa các thành phần components khác nhau trong hệ thống và từ đó nó sẽ hướng chúng ta tới việc quy hoạch phân vùng dữ liệu.\n Có 1 vài quan sát về bản chất dữ liệu mà chúng ta sẽ lưu trữ như sau:\n Chúng ta cần lưu trữ hàng tỷ bản ghi. Mỗi object chúng ta lưu trữ thường rất nhỏ (nhỏ hơn 1K). Không có mối quan hệ relationships giữa các bản ghi records\u0026ndash;hơn là việc cần lưu lại user nào tạo ra URL. Service thiên về read.  Database schema Chúng ta cần có 2 bảng tables: 1 dùng để lưu trữ thông tin về URL mapping và 1 bảng lưu trữ về thông tin user data người đã tạo ra short link.\nLoại database nào mà ta nên sử dụng? Do ta ước tính cần lưu trữ hàng tỷ bản ghi và ta không cần sử dụng mối quan hệ relationships giữa các objects - 1 NoSQL giống như DynamoDB, Cassandra hay Riak là lựa chọn phù hợp. Lựa chọn theo hướng NoSQL sẽ giúp dễ dàng mở rộng scale hơn.\n6. Basic System Design và Algorithm Vấn đề mà ta muốn giải quyết tại đây là cách tạo ra 1 định danh ngắn gọn và duy nhất cho 1 URL nào đó. Trong ví dụ về TinyURL ở phần 1, shortened URL có giá trị là \u0026ldquo;https://tinyurl.com/rxcsyr3r\u0026quot;. 8 kí tự cuối trong chuỗi URL này chính là định danh mà ta muốn tạo. Ta sẽ đưa ra 2 giải pháp tại đây:\na. Mã hóa URL gốc Ta có thể tạo ra 1 chuỗi unique hash (MD5 hay SHA256) từ 1 URL đã cho. Chuỗi hash có thể được mã hóa lại cho việc hiện thị. Chuỗi mã hóa encoding này có thể là base36 ([a-z ,0-9]) hoặc base62 ([A-Z, a-z, 0-9]) và nếu ta thêm vào các ksi tự \u0026lsquo;+\u0026rsquo; và \u0026lsquo;/\u0026rsquo; ta có thể sử dụng base64 encoding. 1 Câu hỏi cần được đặt ra là độ dài về định danh short key là bao nhiêu? 6,8,hay 10 kí tự?\nSử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 6 kí tự, sẽ tạo ra được 64^6 = ~68.7 tỷ định danh. Sử dụng mã hóa base64 encoding, thì với 1 định danh có độ dài là 8 kí tự, sẽ tạo ra được 64^8 = ~281 tỷ tỷ định danh.\nVới 68.7B unique strings, chúng ta giả định là định danh có độ dài là 6 kí tự là đủ cho hệ thống mà ta đang xây dựng.\nNếu ta sử dụng thuật toán MD5 algorithm hay các hash function, nó sẽ tạo ra chuỗi hash có giá trị 128-bit. Sau khi mã hóa base64 encoding, ta sẽ nhận được 1 chuỗi string có nhiều hơn 21 kí tự (do mỗi 1 kí tự base64 sẽ mã hóa 6 bits của chuỗi hash). Dù ta lưạ chọn định danh key có độ dài là 6 hay 8, thì ta vẫn gặp phải vấn đề là trùng lặp key; để giải quyết vấn đề này, ta có thể lựa chọn 1 vài kí tự khác nằm ngoài các chuỗi kí tự dùng để mã hóa.\nNhững issues nào ta sẽ phải đối mặt? Chúng ta sẽ đối mặt với 2 vấn đề với giải pháp mã hóa encoding:\n Nếu có nhiều users cùng nhập vào cùng 1 URL, thì họ sẽ lấy ra cùng 1 shortened URL, điều này là không thể chấp nhận được. Nếu 1 vài phần trong URL là đã được mã hóa URL-encoded thì sao? ví dụ http://www.educative.io/distributed.php?id=design và http://www.educative.io/distributed.php%3Fid%3Ddesign là giống URL trước ở dạng mã hóa URL encoding.  Cách giải quyết các issues: Chúng ta có thể thêm vào 1 chuỗi number tự tăng vào mỗi input URL để nó thành unique và sau đó tạo ra chuỗi hash. Ta không cần lưu trữ chuỗi number tự tăng này vào trong databases. Do đó, các vấn đề có thể gặp phải với cách giải quyết này là chuỗi number tự tăng này ngày càng tăng. Nó có thể tăng mãi mãi? Việc thêm vào 1 chuỗi number tự tăng cũng ảnh hưởng tới hiệu năng của service.\nCách giải quyết khác là thêm vào user id (sẽ là unique) vào input URL. Tuy nhiên, nếu user không đăng nhập, ta sẽ phải yêu cầu user chọn 1 chuỗi key duy nhất. Sau tất cả thì ta vẫn phải đối mặt với 1 mâu thuẫn conflict, ta sẽ phải giữ việc tạo ra định danh key cho tới khi ta tạo ra được 1 chuỗi key unique.\n  b. Tạo định danh keys offline Chúng ta đã có 1 standalone Key Generation Service (KGS) dùng để tạo ra trước các chuỗi 6 ký tự ngẫu nhiên và sau đó lưu trữ chúng vào trong 1 database (ta gọi chúng là key-DB). Bất cứ khi nào chúng ta muốn làm ngắn 1 URL, ta sẽ lấy các keys đã được tạo sẵn trước đó và sử dụng nó. Cách tiếp cận này sẽ khiến mọi thứ trở nên đơn giản và nhanh hơn. Chúng ta không những không cần mã hóa URL mà còn không phải lo lắng về sự trùng lặp hay mâu thuẫn. KGS sẽ đảm bảo mọi keys được insert vào key-DB là duy nhất.\nViệc xử lý song song có gây ra vấn đề gì không? Khi key được sử dụng, nó sẽ được đánh dấu trong database để chắc chắn rằng nó không được sử dụng lại lần nữa. Nếu có nhiều servers cùng đọc keys này vào cùng 1 thời điểm song song, chúng ta sẽ phải đối mặt với ngữ cảnh khi mà có 2 hay nhiều hơn servers cùng đọc cùng 1 key từ database. Cách nào để ta giải quyết vấn đề xử lý song song này?\nServers có thể sử dụng KGS để đọc/đánh dấu các keys trong database. KGS có thể sử dụng 2 tables để lưu trữ keys: 1 tables dùng cho các keys chưa được sử dụng, và 1 table cho tất cả các keys đã được sử dụng. KGS cấp phát các keys cho 1 trong các servers này, và chúng sẽ thực hiện di chuyển key sang bảng table lưu trữ keys đã sử dụng. KGS có thể luôn luôn giữ 1 vài keys trong memory để cấp phát chúng bất cứ khi nào servers cần tới chúng.\nĐể đơn giản, KGS sẽ nạp 1 vài keys vào memory, nó có thể di chuyển chúng sang table chứ các keys đã được sử dụng. Điều này đảm bảo mỗi server sẽ lấy về các unique keys. Nếu KGS dies trước khi gán tất cả các keys đã được loaded tới 1 vài server, chúng ta sẽ lãng phí những keys này\u0026ndash;điều này có thể chấp nhận được.\nKGS cũng đảm bảo không cấp phát trùng keys tới nhiều servers. Ví dụ, nó sẽ phải thực hiện đồng bộ (hay lock) cấu trúc dữ liệu data structure dùng để lưu trữ keys trước khi xóa bỏ những keys này khỏi nó vào cấp phát chúng cho 1 server.\nKích thước key-DB này là bao nhiêu? Với base64 encoding, ta có thể tạo ra được 68.7B chuỗi unique keys có độ dài là 6 kí tự. Nếu ta cần 1 byte để lưu trữ 1 kí tự alpha-numeric, thì ta cần:\n6 (characters per key) * 68.7B (unique keys) = 412 GB. KGS có single point of failure nào không? Có. Để giải quyết vấn đề này, ta cần có 1 standby replica của KGS. Bất cứ khi nào, primary server dies thì standby server sẽ thay thế vai trò của nó để tạo và cấp phát keys.\nMỗi app server có thực hiện cache 1 vài keys từ key-DB? Có, điều này có thể tăng tốc. Mặc dù, trong trường hợp này, nếu application server dies trước khi tiêu thụ tất cả các keys, chúng ta sẽ chấp nhận để mất các keys đó. Điều này có thể chấp nhận do chúng ta có 68B unique keys có độ dài là 6 kí tự.\nCách chúng ta thực hiện xử lý key lookup? Ta có thể lookup key trong database để lấy ra full URL. Nếu nó tồn tại trong DB, thì ta sẽ tạo ra “HTTP 302 Redirect” status tới browser, chuyển tiếp stored URL vào trong trường “Location” field của request. Nếu key không tồn tại trong hệ thống, thì ta tạo ra “HTTP 404 Not Found” status hoặc chuyển hướng user về lại homepage.\nTa có nên áp đặt hạn mức size limits vào các định danh tùy chỉnh custom aliases? Dịch vụ của ta có hỗ trợ custom aliases. Users có thể lựa chọn bất cứ định danh \u0026lsquo;key\u0026rsquo; nào mà họ thích, nhưng việc cung cấp 1 custom alias là không bắt buộc. Tuy nhiên, ta cần áp đặt hạn mức size limit vào các custom alias để đảm bảo chúng ta có 1 URL database nhất quán. Chúng ta giả định user có thể định nghĩa 1 độ dài tối đa là 16 kí tự trên mỗi customer key (nó đã được phản ánh như trong database schema ở trên)\n7. Phân vùng Data Partitioning và Replication Để mở rộng scale out DB, chúng ta cần phân tán dữ liệu do nó cần chứa hàng tỷ URLs. Do đó, chúng ta cần phát triển 1 partitioning scheme có khả năng phân tán và chia nó và lưu trữ nó ở trên nhiều các DB servers khác nhau.\na. Phân tán dữ liệu theo Range based: ta có thể lưu trữ URLs vào các phân vùng partitions tách biệt dựa vào kí tự đầu tiên của chuỗi hash key. Do đó ta có thể lưu tất cả các URL bất đầu với kí tự \u0026lsquo;A\u0026rsquo; hay \u0026lsquo;a\u0026rsquo; ở trong 1 phân vùng partition, tương tự lưu các URL bắt đầu với kí tự \u0026lsquo;B\u0026rsquo; trong 1 phân vùng partition khác. Cách tiếp cận này được gọi là range-based partitioning. Chúng ta thậm chí có thể nhóm gộp các kí tự ít xuất hiện vào trong cùng 1 database partition. Do đó, chúng ta có thể phát triển 1 static partitioning scheme để luôn lưu trữ/tìm ra 1 URL theo 1 cách dễ đoán định.\nVấn đề chính với cách tiếp cận này là nó có thể dẫn tới việc DB servers không được cân bằng tải. Ví dụ, ta có thể quyết định lưu trữ tất cả URLs bắt đầu với ksi tự \u0026lsquo;E\u0026rsquo; vào trong phân vùng 1 DB partition, nhưng nếu sau này khi chúng ta lại có quá nhiều URLs bắt đầu với kí tự \u0026lsquo;E\u0026rsquo;.\nb. Phân tán dữ liệu theo Hash-Based: Theo schema này, chúng ta tạo ra 1 chuỗi hash của object mà ta đang lưu trữ. Sau đó ta tính toán được phân vùng partition nào được sử dụng dựa trên chuỗi hash. Trong trường hợp của chúng ta, ta có thể lấy hash của định danh \u0026lsquo;key\u0026rsquo; hay short link để xác định phân vùng partition dùng để lưu trữ data object.\nHàm hashing function sẽ tạo ra các URLs phân phối ngẫu nhiên vào các phân vùng partitions khác nhau (ví dụ hàm hashing function có thể luôn luôn ánh xạ bất kỳ \u0026lsquo;key\u0026rsquo; nào đó với 1 số trong khoảng [1\u0026hellip;256]). Số này sẽ biểu thị cho phân vùng partition mà ta lưu trữ object ở trong nó.\nCách tiếp cận này có thể hướng tới việc quá tải overloaded partitions, vấn đề này có thể được giải quyết bằng cách sử dụng Consistent Hashing.\n8. Cache Chúng ta có thể cache các URLs thường xuyên được truy cập. Ta có thể sử dụng bất cứ giải pháp nào có sẵn như Memcached, lưu trữ full URLs với chuỗi định danh hashes tương ứng của nó. Do vậy, application servers, trước khi hitting vào backend storage, chúng ta có thể nhanh chóng kiểm tra được nếu cache có chứa URL đang được request.\nBao nhiêu cache memory mà ta sẽ sử dụng? Chúng ta có thể bắt đầu dựa trên 20% traffic truy cập hàng ngày và dựa trên ước lượng sử dụng của client, ta có thể biết được bao nhiêu cache servers mà ta cần. Giống như việc định lượng ở trên, chúng ta cần 170GB memory để cache 20% daily traffic. Do các server hiện đại ngày nay có thể có tới 256GB memory, nên ta có thể dễ dàng chứa tất cả các cache của hệ thống trên 1 máy. Hay cách khác, ta có thể sử dụng 1 nhóm các servers nhỏ hơn để chứa các hot URLs này.\nChính sach loại bỏ cache nào sẽ phù hợp nhất với yêu cầu hệ thống? Khi cache đầy, và ta muốn thay thế 1 link với 1 URL mới hay hot hơn, ta sẽ làm điều này bằng cách nào? Chính sách Least Recently Used (LRU) có thể phù hợp với hệ thống. Với chính sách này ta có thể loại bỏ các URL ít được sử dụng gần đây nhất. Ta có thể sử dụng cấu trúc dữ liệu Linked Hash Map hay cấu trúc dữ liệu tương tụ để lưu trữ các URLs và các định danh Hashes, cấu trúc này sẽ trợ giúp ta track được các URLs mà được truy cập gần đây.\nĐể tăng hiệu quả, ta có thể nhân bản replicate các caching servers để phân phối tải load giữa chúng.\nCách mà mỗi cache replica được cập nhật? Bất cứ khi nào cache miss, servers sẽ hitting vào backend database. Bất cứ khi nào việc này xảy ra, ta có thể cập nhật cache và chuyển tiếp dữ liệu mới vào tất cả các cache replicas. Mỗi replica có thể cập nhật cache của nó bằng cách thêm vào dữ liệu mới. Nếu 1 replica đã có dữ liệu này, thì nó có thể đơn giản từ chỗi cập nhật.\n  9. Cân bằng tải Load Balancer (LB) Ta có thể thêm 1 lớp cân bằng tải Load balancing layer vào 3 vị trí sau trong hệ thống:\n Giữa Clients và Application servers. Giữa Application Servers và database servers. Giữa Application Servers và Cache servers.  Đầu tiên, ta có thể sử dụng cách tiếp cận Round Robin đơn giản để phân phối các incoming requests cân bằng giữa các backend servers. Đây là cách cân bằng tải LB đơn giản để thực thi. 1 ưu điểm khác của cách tiếp cận này là nếu 1 server chết thì LB sẽ loại bỏ nó ra khoản nhóm vòng xoay và sẽ ngừng gửi traffic tới nó.\n1 vấn đề phát sinh với Round Robin LB là nó không quan tâm tới tải server load. Do vậy, nếu 1 server bị quá tải hay bị chậm thì LB sẽ không ngừng gửi request mới tới server đó. Để khắc phục vấn đề này, 1 giải pháp LB thông minh hơn có thể được áp dụng là LB sẽ định kỳ truy vấn về tải của backend server và điểu chỉnh traffic dựa vào đó.\n10. Thanh lọc và dọn dẹp DB Các dữ liệu có nên tồn tại mãi mãi hay nên được thanh lọc? Nếu thời gian hết hạn do user định nghĩa đã đến thì điều gì cần nên làm với các link hết hạn này?\nNếu ta chọn cách liên tục tìm kiếm các links đã hết hạn để xóa chúng, thì nó gây sức ép lớn đến database. Thay vào đó, ta có thể chậm rãi xóa bỏ các links cũ đã hết hạn này bằng cách dọn dẹp kiểu lazy cleanup. Service của chúng ta cũng cần chắc chắn với các links hết hạn thì sẽ được xóa dù 1 vài links đã hết hạn vẫn sống lâu hơn nhưng nó sẽ không bao giờ được trả về cho users.\n Bất cứ khi nào user thử truy cập vào 1 link hết hạn, ta có thể xóa link này và trả về lỗi cho user. 1 Cleanup service độc lập sẽ chạy định kỳ để xóa các links đã hết hạn ra khỏi storage và cache. Service này sẽ rất nhẹ và được lập lịch chạy vào thời điểm mà user traffice thấp. Ta luôn có 1 ngưỡng thời gian hết hạn cho từng link (ví dụ: 2 năm). Sau khi xóa 1 link đã hết hạn, ta có thể lưu lại key trở lại key-DB để tái sử dụng lại. Ta cũng nên xoá các links mà không được truy cập sau 1 khoảng thời gian, ví dụ như 6 tháng? Đây có thể là 1 mẹo. Do lưu trữ storage tương đối rẻ, ta cũng có thể quyết định lưu trữ links mãi mãi.  11. Telemetry Có tổng số bao nhiêu lần 1 short URL được sử dụng, hay user truy cập chúng từ đâu? Cách mà ta sẽ lưu trữ các thống kê này? Nếu mỗi lần có 1 view mới ta lại thực hiện cập nhật 1 DB row, thì điều gì sẽ xảy ra khi 1 URL phổ biến có 1 lượng lớn các concurrent requests?\nMột vài thống kê khác cũng đáng để theo dõi: quốc gia của các visitor, thời điểm của các truy cập, các web page tham chiếu tới, browser, hay platform của các visitor.\n12. Bảo mật và quyền hạn Security và Permissions Users có thể tạo ra các private URLs hay cho phép 1 tập các users cụ thể nào đó được phép truy cập URL?\nChúng ta có thể lưu trữ mức quyền hạn permission level (public/private) với từng URL trong database. Ta có thể tạo ra 1 bảng table riêng để lưu trữ các UserIDs có quyền truy cập 1 URL cụ thể. Nếu 1 user không có quyền hay cố gắng truy cập vào 1 URL, ta có thể gửi 1 lỗi (HTTP 401). Như đã trình bày ở trên, chúng ta đang lưu trữ dữ liệu trong NoSQL wide-column database như Cassandra, khóa key cho table lưu trữ quyền hạn permissions sẽ là \u0026lsquo;Hash\u0026rsquo; hay chuỗi do KGS sinh ra. Cột này sẽ lưu trữ giá trị của các UserIDs được phép truy cập URL.\n","permalink":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-a-url-shortening-service-like-tinyurl/","summary":"1. Tại sao chúng ta cần 1 dịch vụ kiểu làm ngắn URL shortening? URL shortening được sử dụng để tạo ra các định danh ngắn gọn hơn shorter aliases cho các URLs dài dòng. Chúng ta gọi các định danh được làm ngắn này là các \u0026ldquo;short links.\u0026rdquo;. Các users được điều hướng tới URL gốc khi họ thực hiện truy cập vào các short links này. Các short links sẽ tiết kiệm nhiều không gian khi hiện thị, in ấn, truyền thông điệp hay tweeted.","title":"Bài 2: Cách thiết kế 1 dịch vụ URL Shortening service giống như TinyURL"},{"content":"1. Instagram là gì? Instagram là 1 dịch vụ mạng xã hội cho phép người dùng users upload và chia sẻ các hình ảnh photos và videos của họ với những người khác. Người dùng Instagram có thể lựa chọn chia sẻ thông thông qua cả 2 hình thức công khai publicly và riêng tư privately. Bất cứ thứ gì được chia sẻ công khai có thể được nhìn thấy bởi người dùng khác, mặt khác những nội dung chia sẻ riêng tư sẽ chỉ được truy cập bởi 1 nhóm người dùng cụ thể. Instagram cho phép người dùng nó chia sẻ thông qua nhiều nền tảng mạng xã hội khác, giống như Facebook, Twitter, Flickr, và Tumblr.\nChúng ta sẽ lên kế hoạch thiết kế 1 phiên bản đơn giản hơn của Instagram vì mục đích thiết kế, nơi mà người dùng user có thể chia sẻ photos và follow những người khác. \u0026ldquo;News Feed\u0026rdquo; cho từng user sẽ chỉ bao gồm các top photos của tất cả gười dùng khác mà user đang follows.\n2. Yêu cầu Requirements và mục tiêu Goals của hệ thống Chúng ta sẽ tập trung vào các tập yêu cầu như sau khi thực hiện thiết kế Instagram.\nCác yêu cầu về mặt tính năng:\n Users có thể upload/download/view photos. Users có thể thực hiện các tìm kiếm trên các tiêu đề photo/video. Users có thể theo dõi follow người khác. Hệ thống sẽ tạo và hiện thị News Feed của user - Chứa các top photos của tất cả các người dùng mà họ theo dõi.  Yêu cầu không liên quan tới tính năng:\n Hệ thống cần có tính sẵn sàng cao. Độ trễ có thể chấp nhận được của hệ thống là 200ms cho việc tạo ra News Feed. Hệ thống chấp nhận tính nhất quán có thể ảnh hưởng nếu người dùng không nhìn thấy 1 photo trong 1 khoảng thời gian. Hệ thống có độ tin cậy cao, bất cứ photo hay video nào đã được upload thì sẽ không bao giờ bị mất.  Không nằm trong scope: Việc theo tags vào photos, tìm kiếm photos dựa trên tag, bình luận vào photos, tagging người dùng user vào photos, etc.\n3. 1 vài chú ý cần xem xét đến khi thực hiện thiết kế Hệ thống sẽ nặng tải về read, do vậy ta sẽ tập trung vào xây dựng 1 hệ thống sao cho việc lấy ra các photos 1 cách nhanh nhất.\n Thực tế, users có thể upload bao nhiêu photos tùy thích, do vậy việc quản lý lưu trữ storage 1 cách hiệu quả sẽ là 1 nhân tố đóng vai trò quan trọng trong thiết kế hệ thống. Độ trễ thấp như kỳ vọng khi thực hiện viewing photos. Data cũng cần 100% tin cậy. Nếu 1 user upload 1 photo thì hệ thống sẽ đảm bảo nó sẽ không bao giờ bị mất.  4. Định lượng sức chứa Capacity và các ràng buộc Constraints  Ta giả sử chúng ra có tổng số 500M users, với 1M user hoạt động hàng ngày. 2M photos mới được tạo ra mỗi ngày, 23 new photos mỗi giây. Trung bình kích thước 1 photo =\u0026gt; 200KB. Tổng số lưu trữ bắt buộc cho tất cả photos trong 1 ngày là: 2M * 200KB =\u0026gt; 400 GB Tổng số lưu trữ bắt buộc cho tất cả photos trong 10 năm là: 400GB *365 (days a year)* 10 (years) ~= 1425TB  5. High Level System Design Ở mức high-level, chúng ta cần support 2 ngữ cảnh, 1 là thực hiện upload photos, 2 là khi thực hiện view/search photos. Do đó dịch vụ chúng ta thiết kế sẽ cần các object storage servers để lưu tữ photos và database servers để lưu trữ các thông tin metadata của photos.\n6. Database Schema  Việc định nghiã DB schema ở những giai đoạn đầu tiên của cuộc phỏng vấn sẽ giúp mọi người hiểu về luồng data flow giữa các thành phần components khác nhau trong hệ thống và giúp định hướng cách phân vùng dữ liệu data partitioning sau này.\n Chúng ta cần lưu trữ dữ liệu về users, các photos được upload lên bởi họ, những người họ đang theo dõi follow. bảng Photo sẽ chứa tất cả các dữ liệu liên quan tới ảnh photo; chúng ta cần đánh index trên cặp (PhotoID, CreationDate) do ta cần lấy ra những photo được upload lên gần đây trước tiên.\n1 cách tiếp cận hết sức hiển nhiên cho việc lưu trữ giống như database schema ở trên là sử dụng 1 RDBMS như MySQL do ta có sử dụng đến joins. Nhưng databases quan hệ cũng đi cùng những thách thức của chúng, đặc biệt là khi ta cần mở rộng scale chúng.\nChúng ta có thể lưu trữ photos ở những hệ thống lưu trữ phân tán file distributed file storage giống như HDFS hay S3.\nChúng ta có thể lưu trữ dữ liệu ở schema trên dưới dạng lưu trữ phân tán distributed key-value để tận dựng được các ưu điểm của NoSQL. Tất cả các thông tin metadata liên quan tới photos lưu trữ trong 1 table mà có key là \u0026lsquo;PhotoID\u0026rsquo; và value sẽ la 1 object chứa các thông tin PhotoLocation, UserLocation, CreationTimestamp, etc.\nNếu chúng ta chọn giải pháp sử dụng 1 NoSQL database, chúng ta cần thêm 1 table nữa để lưu trữ quan hệ relationships giữa users và photos để biết được ai đang sở hữu photo nào. Chúng ta sẽ gọi bảng này là \u0026lsquo;UserPhoto\u0026rsquo;. Chúng ta cũng cần lưu trữ danh sách các người mà 1 user đang theo dõi follow. Chúng ta gọi bảng này là \u0026lsquo;UserFollow\u0026rsquo;. Với những bảng table dạng này, ta có thể sử dụng 1 kiểu wide-column datastore giống như Cassandra. Ví với bảng UserPhoto, với key là UserID và value là danh sách các PhotoIDs mà user sở hữu, được lưu trữ ở các cột columns khác nhau. Chúng ta sẽ có schema tương tự cho bảng UserFollow.\nCassandra hay các kiểu key-value stores, thông thường luôn duy trì 1 số lượng các bản sao replicas để đảm bảo tính sẵn sàng của hệ thống. Và cũng ở trong những data stores dạng này, việc xóa deletes sẽ không được áp dụng ngay lập tức; dữ liệu data sẽ vẫn còn được lưu trữ trong vài ngày (hỗ trợ trường hợp muốn undeleting) trước khi bị xóa vĩnh viễn khỏi hệ thống.\n7. Ước lượng Data Size Chúng ta sẽ ước lượng cách mà dữ liệu data sẽ gia tăng ở từng bảng table và tổng số lưu trữ storage mà ta cần lưu trữ trong 10 năm.\nUser: Giả sử rằng mỗi kiểu dữ liệu \u0026lsquo;int\u0026rsquo; và \u0026lsquo;dataTime\u0026rsquo; cần 4 bytes để lưu trữ, mỗi dòng row trong bảng User sẽ cần 68 bytes:\nUserID (4 bytes) + Name (20 bytes) + Email (32 bytes) + DateOfBirth (4 bytes) + CreationDate (4 bytes) + LastLogin (4 bytes) = 68 bytes Nếu chúng ta có 500M users, thì ta sẽ cần 32GB để lưu trữ:\n500 million * 68 ~= 32GB Photo: Mỗi row trong bảng Photo sẽ cần 284 bytes:\nPhotoID (4 bytes) + UserID (4 bytes) + PhotoPath (256 bytes) + PhotoLatitude (4 bytes) + PhotoLongitude(4 bytes) + UserLatitude (4 bytes) + UserLongitude (4 bytes) + CreationDate (4 bytes) = 284 bytes Nếu có 2M photos mới được upload mỗi ngày, chúng ta sẽ cần 0.5GB lưu trữ cho mỗi ngày:\n2M * 284 bytes ~= 0.5GB per day Với 10 năm, ta sẽ cần 1.88TB lưu trữ.\nUserFollow: Mỗi row trong UserFollow sẽ cần 8 bytes. Nếu ta có 500M users và trung bình mỗi user sẽ thực hiện theo dõi follow 500 người khác. Chúng ta sẽ cần 1.82TB lưu trữ cho UserFollow:\n500 million users * 500 followers * 8 bytes ~= 1.82TB Tổng dung lượng cần để lưu trữ tất cả các tables trong vòng 10 năm sẽ là 3.7TB:\n32GB + 1.88TB + 1.82TB ~= 3.7TB 8. Component Design Việc photo được upload (hay write) có thể trở nên chậm nếu chúng được ghi trực tiếp vào ổ disk, trong khi việc đọc reads sẽ nhanh hơn, đặc biệt nếu chúng được đọc từ cache.\nNhững người dùng thực hiện upload có thể sử dụng hết các connections hiện có của hệ thống, do việc thực hiện uploading được xét là 1 slow process. Điều này có nghĩa là reads có thể bị ảnh hưởng nếu hệ thống bị quá tải với các write request. Chúng ta cũng cần lưu ý rằng 1 web server luôn có 1 ngưỡng giới hạn connection limit. Ta giả sử rằng web server có 1 ngưỡng giới hạn là 500 connections tại 1 thời điểm, thì nó không thể có hơn 500 uploads hay reads cùng lúc. Để khắc phục nghẽn cổ chai này, ta có thể phân chia reads và writes vào các serivces độc lập. Chúng ta sẽ có các servers dành riêng cho việc reads và các server khác dành riêng cho việc writes để đảm bảo việc upload không ảnh hưởng tới cả hệ thống.\nViệc tách biệt read và write requests cũng cho phép ta mở rộng và tối ưu từng loại xử lý 1 cách độc lập:\n9. Độ tin cậy Reliability và tính dư thừa Redundancy Việc để mất mát các files không được phép xảy ra ở trong hệ thống. Do đó, ta cần lưu trữ nhiều bản copies của từng file và do đó nếu storage server dies thì ta vẫn có thể lấy ra được photo từ các bản copy của nó ở những storage server khác.\nĐịnh luật này cũng sẽ được áp dụng cho các thành phần components khác trong hệ thống. Nếu ta muốn hệ thống có tính sẵn sàng cao, chúng ta cần có nhiều bản sao chép replicas của các services đang chạy trong hệ thống do nếu có 1 vài services die thì hệ thống vẫn chạy và đảm bảo sẵn sàng. Tính dư thừa Redundancy sẽ xóa bỏ điểm yếu single point of failure của hệ thống.\nViệc tạo ra dư thừa redundancy trong 1 hệ thống có thể xóa bỏ rủi ro single points of failure và cung cấp khả năng backup hay dự phòng nếu cần khi hệ thống gặp rủi ro. Ví dụ, nếu có 2 instances của cùng 1 service đang chạy trên production và khi 1 cái fail, thì hệ thống có thể chuyển đổi dự phòng failover tới bản copy khỏe mạnh. Failover có thể xảy ra 1 cách tự động và không đòi hỏi bất kỳ sự can thiệp thủ công nào.\n10. Data Sharding Giờ chúng ta sẽ bàng tới các kiểu schemes khác nhau phục vụ cho metadata sharding:\na. Partitioning dựa vào UserID Ta gỉa sử rằng chúng ta sẽ shard dựa trên \u0026lsquo;UserID\u0026rsquo; do đó ta có thể giữ mọi photos của 1 user nằm trong cùng 1 shard. Nếu 1 DB shard là 1 TB, chúng ta sẽ cần 4 shards để lưu trữ 3.7TB dữ liệu. Chúng ta sẽ giả sử rằng, vì lí do performace và scalability tốt hơn, ta sẽ cần 10 shards.\nDo vậy ta sẽ tính được shard number bằng cách lấy số dư UserID chia cho 10 và sẽ lưu trữ dữ liệu data trên shard number đó. Để xác định được tính unique của photo trong hệ thống, ta cần thêm thông tin shard number vào sau mỗi PhotoID.\nCách mà ta sẽ tạo ra PhotoIDs? Mỗi DB shard sẽ có riêng cho mình 1 chuỗi tự tăng auto-increment sequence cho PhotoIDs, và do đó ta sẽ thêm ShardID vào sau mỗi PhotoID, ta sẽ khiến nó unique trên toàn hệ thống.\nNhững vấn đề sẽ phát sinh với kiểu phân tán partitioning scheme này?\n Cách mà ta sẽ xử lý đối với hot users? rất nhiều người theo dõi follow những hot users này, và cũng rất nhiều người khác xem những photo mà những user này upload lên. 1 vài users sẽ có rất nhiều photos so với những người khác, do vậy nó sẽ tạo ra sự phấn tán lưu trữ không đồng đều. Chúng ta phải làm gì nếu ta không lưu trữ được tất cả các ảnh của 1 người dùng trên cùng 1 shard? Nếu ta phân tán photos của 1 user ra trên nhiều shards, thì nó có gây ra độ trễ lớn? Việc lưu trữ tất cả các photos của 1 user trên cùng 1 shard có thể gây ra các vấn đề như độ sẵn sàng của tất cả các dữ liệu của user sẽ không truy cập được nếu shard down và độ trễ cao nếu shard nó đang cao tải.  b. Partitioning dựa vào PhotoID Nếu ta có thể tạo ra unique PhotoIDs trước và sau đó xác định shard number dựa vào “PhotoID % 10”, các vấn đề đặt ra ở trên sẽ được giải quyết. Ta cũng không cần thêm thông tin ShardID vào sau PhotoID trong trường hợp này, do PhotoID bản thân nó đã unique trên toàn bộ hệ thống.\nCách mà ta tạo ra PhotoIDs? theo cách này, ta không cần 1 chuỗi tự tăng auto-incrementing sequence ở mỗi shard để định nghĩa PhotoID bởi vì ta cần biết về PhotoID trước để xác định ra shard number mà ta dùng để lưu trữ dữ liệu. 1 giải pháp khác là ta có thể danh riêng 1 database instance để tạo ra các IDs tự tăng auto-incrementing IDs. Nếu PhotoID có thể chứa đủ trong 64 bits, ta có thể định nghĩa 1 table chỉ chứa 64 bit ID field. Do vậy bất cứ khi nào ta thêm 1 photo vào hệ thống, ta có thể thêm mới 1 row mới vào table này và lấy giá trị ID đó làm PhotoID của 1 photo mới.\nhệ thống key generating DB này có phải là 1 single point of failure? Đúng vậy. 1 cách giải quyết cho vấn đề này là ta có thể sử dụng 2 databases, 1 cái chỉ tạo ra các IDs lẻ, và cái còn lại tạo ra IDs chẵn. Ví dụ với MySQL, ta có thể sử dụng scripts sau để định nghĩa chuỗi sequences:\nKeyGeneratingServer1: auto-increment-increment = 2 auto-increment-offset = 1 KeyGeneratingServer2: auto-increment-increment = 2 auto-increment-offset = 2 Ta có thể đặt 1 cân bằng tải load balancer ở trước những databases này để cân bằng tải round-robin giữa chúng và cũng để giải quyết vấn đề downtime. Khi cả 2 servers bị rơi khỏi sự đồng bộ này, thì sẽ naỷ sinh ra trường hợp server này sẽ tạo ra nhiều keys hơn so với cái còn lại, nhưng điều này không gây ra vấn đề gì cho hệ thống. Chúng ta có thể mở rộng cách thiết kế này bằng cách định nghĩa ra các bảng ID dành riêng cho Users, Photo-Comments, hay bất cứ các đố tượng object nào khác mà có trong hệ thống.\nCách chúng ta hoạch định cho việc phát triển của hệ thống trong tương lai? Chúng ta có thể có 1 lượng lớn số phân vùng dữ liệu logical partitions để đáp ứng cho sự phát triển của dữ liệu trong tương lai, giống như thời điểm bắt đầu, có thể có nhiều multiple logical partitions nằm trên cùng 1 database server vật lý. Do mỗi database server có thể có nhiều database instances chạy trên nó, chúng ta có thể có nhiều databases tách biệt nhau trên cùng 1 phân vùng logical partition ở bất cứ server nào. Do đó, bất cứ khi nào ta cảm thấy 1 database server nào đó có nhiều dữ liệu, ta có thể migrate 1 vài phân vùng logical partitions từ nó sang server khác. Ta có thể dựa trên 1 config file (hay config theo từng database riêng biệt) để map phân vùng logical partitions của ta vào các database servers; điều này cho phép ta di chuyển các phân vùng partitions 1 cách dễ dàng. Bất cứ khi nào ta muốn di chuyển 1 phân vùng partition, ta chỉ phải updat lại config file này để tạo ra sự thay đổi.\n11. Cách tạo hệ thống Ranking và News Feed Để tạo ra News Feed cho bất cứ user nào đó, ta cần lấy ra các photos mới nhất, phổ biến nhất, và photos của những người mà user đó đang theo dõi follow.\nĐể đơn giản, ta có thể giả định rằng ta cần lấy ra 100 photos cho 1 News Feed của 1 user. application server của ta cần lấy ra 1 danh sách các người mà user đang theo dõi và lấy ra thông tin metadata info của 100 photos mới nhất của những người này. Bước cuối, server sẽ submit toàn bộ những photos này tới thuật toán ranking của ta, nó sẽ xác định top 100 photos (dựa trên thời điểm xuất hiện, số lượng like) và trả về chúng cho người dùng. 1 vấn đề ta phải đối mặt là độ trễ cao do ta phải truy vấn nhiều tables và thực hiện sorting/merging/ranking trên tập kết quả. Để cải thiện hiệu năng, ta có thể tạo trước sẵn các News Feed và chứa chúng trong 1 bảng table dành riêng.\nCách tạo trước News Feed: Chúng ta có thể dành riêng các servers để liên tục tạo ra các News Feeds của users và sắp xếp chúng trong bảng UserNewsFeed. Do vậy, bất cứ khi nào user cần các photo mới nhất trong News-Feed, chúng ta sẽ đơn giản truy vấn vào bảng table này để trả về kết quả đó cho user.\nBất cứ khi nào các servers này cần tạo ra News Feed cho 1 user, chúng sẽ truy vấn trong bảng UserNewsFeed trước và tìm ra thời điểm tạo gần nhất của News Feed, dựa vào đó News-Feed mới sẽ được tạo từ thời điểm đó trở lại đây.\nCó những cách nào để gửi các News Feed mới cho các users?\n Pull: Clients có thể pull các News-Feed từ server theo 1 khoảng thời gian định kỳ hay thủ công bất cứ khi nào họ cần. Các vấn đề phát sinh với các tiếp cận này: Dữ liệu mới có thể không được hiện thị ra cho users cho tới khi client thực hiện pull request, Đa số thời gian, pull requests sẽ trả về kết quả rỗng nếu chưa có dữ liệu mới. Push: Server có thể push dữ liệu mới xuống users sớm nhất khi chúng vừa xuất hiện. Để quản lý việc này hiệu quả, users phải duy trì 1 Long Poll request tới server để nhận về updates. Vấn đề phát sinh với cách tiếp cận này: 1 user có thể theo dõi rất nhiều người hay 1 user nổi tiếng có thể có hàng triệu người theo dõi; trong trường hợp này, server phải push updates 1 cách liên tục. Hybrid: Chúng ta có thể sử dụng 1 cách lai hybrid. Chúng ta có thể chuyển tất cả các users mà có số lượng lớn người theo dõi thành kiểu pull-based model và chỉ push data với những user chỉ có 1 vài trăm hay 1 vài ngàn người theo dõi. Cách tiếp cận khắc là có thể để server push updates tới tất cả users mà không hoạt động quá thường xuyên và cho phép các user với nhiều updates pull data 1 cách thường xuyên.  12. Cách tạo News Feed với các Sharded Data 1 trong các yêu cầu quan trọng nhất là việc tạo ra News Feed cho bất cứ user nào đó để lấy về các photos mới nhất từ tất cả những ngừời mà user theo dõi. Để làm được điều này, ta cần có 1 cơ chế để sort photos theo thời gian tạo. Để làm việc này 1 cách hiệu quả, ta có thể thêm thời gian tạo photo là 1 phần của PhotoID. Do đó ta chỉ cần đánh khóa chính vào PhotoID, là có thể dễ dàng nhanh chóng tìm ra được các PhotoIDs mới nhất.\nTa có thể sử dụng epoch time cho việc này. Do vậy PhotoID sẽ gồm có 2 phần: phần đầu tiên sẽ biểu diễn epoch time, phần thứ 2 sẽ là 1 chuỗi tự tăng auto-incrementing sequence. Do vậy khi tạo ra 1 PhotoID mới, ta cần lấy ra epoch time hiện tại và thêm nó vào 1 chuỗi tự tăng auto-incrementing ID từ key-generating DB. Ta có thể dễ dàng xác định shard number từ PhotoID ( PhotoID % 10) này và lưu photo này vào shard number đó.\nKích thước PhotoID là bao nhiêu? Nếu epoch time bắt đầu từ thời điểm hiện tại; và ta sẽ cần bao nhiêu bits để lưu trữ số giây cho 50 năm tới?\n86400 sec/day * 365 (days a year) * 50 (years) =\u0026gt; 1.6 billion seconds Chúng ta cần 31 bits để lưu trữ số này. Do, ta đang kỳ vọng trung bình có 23 photos mới mỗi giây, ta có thể phải cấp phát thêm 9 bits để lưu trữ chuỗi tự tăng auto-incremented sequence nữa. Do mỗi giây, ta có cần lưu trũ 2^9 = 512 photos mới. Chúng ta đang cấp pháy 9 bits cho chuỗi tự tăng là nhiều hơn những gì mà ta yêu cầu; chúng ta làm việc này bằng cách lấy ra 1 số full byte number (as 40 bits = 5 bytes40bits=5bytes). Ta có thể reset lại chuỗi tự tăng auto-incrementing sequence vào mỗi giây.\n13. Cache và Load balancing Chúng ta cần 1 hệ thống phân phối ảnh có khả năng mở rộng lớn để đáp ứng các users nằm phân tán trên toàn cầu. Hệ thống chỉ nên push các bội dung content gần với user bằng cách sử dụng lượng lớn các photo cache servers được phân tán theo vùng địa lý và sử dụng CDNs.\nChúng ta có thể thêm vào 1 cơ chế cache cho metadata servers để cache lại các hot database rows. Chúng ta có thể sử dụng Memcache để cache data, và Application servers trước khi hit vào database có thể nhanh chóng kiểm tra được cache có chứa dữ liệu mong muốn. Chính sách LRU có thể được áp dụng để xóa cache trong hệ thống của ta. Khi dùng chính sách này, ta sẽ loại bỏ được các row ít được xem trước tiên.\nCách mà ta xây dựng 1 hệ thống cache thông minh hơn? Nếu ta tuân theo định luật 80/20, thì 20% tổng sản lượng read hàng ngày sẽ tạo ra 80% traffic, điều này có nghĩa là 1 vài photos nhất định sẽ trở nên phổ biến và được nhiều người đọc chúng. Điều này cho thấy rằng chúng ta có thể thử lưu vào bộ nhớ đệm 20% khối lượng ảnh và metadata đọc hàng ngày.\n","permalink":"https://lifesucks.dev/posts/grokking-system-design-interviews/designing-instagram/","summary":"1. Instagram là gì? Instagram là 1 dịch vụ mạng xã hội cho phép người dùng users upload và chia sẻ các hình ảnh photos và videos của họ với những người khác. Người dùng Instagram có thể lựa chọn chia sẻ thông thông qua cả 2 hình thức công khai publicly và riêng tư privately. Bất cứ thứ gì được chia sẻ công khai có thể được nhìn thấy bởi người dùng khác, mặt khác những nội dung chia sẻ riêng tư sẽ chỉ được truy cập bởi 1 nhóm người dùng cụ thể.","title":"Bài 4: Cách thiết kế  Instagram"}]